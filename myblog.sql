/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50719
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 50719
 File Encoding         : 65001

 Date: 12/06/2020 21:40:21
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `views` int(11) NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `comment_count` int(255) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 75 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (64, b'1', b'1', '<!--DOCTYPE:告诉浏览器使用标准-->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>基本标签学习</title>\r\n</head>\r\n<body>\r\n<!--标题标签-->\r\n<h1>一级标签</h1>\r\n<h2>二级标签</h2>\r\n<h3>三级标签</h3>\r\n<h4>四级标签</h4>\r\n<h5>五级标签</h5>\r\n<h6>六级标签</h6>\r\n<!--段落标签-->\r\n<!--分段-->\r\n<p>两只老虎    两只老虎</p>\r\n<p>跑得快       跑得快</p>\r\n<p>一只没有耳朵     一只没有尾巴</p>\r\n<p>真奇怪      真奇怪</p>\r\n<p>两只老虎     两只老虎</p>\r\n<p>跑得快        跑得快</p>\r\n<p>一只没有耳朵    一只没有尾巴</p>\r\n<p>真奇怪      真奇怪</p>\r\n<!--水平线标签-->\r\n<hr/>\r\n<!--换行标签-->\r\n两只老虎    两只老虎<br/>\r\n跑得快百       跑得快<br>\r\n一只度没有耳朵     一只没有尾巴<br/>\r\n真奇怪      真奇怪<br/>\r\n两只老虎     两只老虎<br/>\r\n跑得快        跑得快<br/>\r\n一只没有耳朵    一只没有尾巴<br/>\r\n真奇怪      真奇怪<br/>\r\n<!--粗体;斜体-->\r\n粗体:<strong>I Love You</strong><br/>\r\n斜体:<em>I Love You</em><br/>\r\n\r\n<!--特殊符号-->\r\n空               格\r\n空&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格\r\n<br/>\r\n&gt;\r\n<br/>\r\n&lt;\r\n<br/>\r\n&copy;版权所有\r\n</body>\r\n</html>', '2020-05-24 05:38:34', 'HTML<标签>学习', 'https://images.unsplash.com/photo-1560525507-3aa7258547f8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'HTML', '2020-06-11 05:04:31', 9, 63, 1, 0);
INSERT INTO `t_blog` VALUES (65, b'1', b'1', '## VO\r\n\r\nvalue object：值对象\r\n\r\n通常用于业务层之间的数据传递，由new创建，由GC回收。\r\n\r\n\r\n\r\n## PO\r\n\r\npersistant object：持久层对象\r\n\r\n对应数据库中表的字段。\r\n\r\nVO和PO，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。\r\n\r\n## DTO\r\n\r\ndata transfer object：数据传输对象。\r\n\r\n表里面有十几个字段：id,name,gender(M/F),age,conmpanyId(如001)...\r\n\r\n页面需要展示四个字段：name,gender(男/女),age,conmpanyName(如今日头条股份有限公司)。\r\n\r\nDTO由此产生，一是能提高数据传输的速度（减少了传输字段），二能隐藏后端表结构。\r\n\r\n\r\n## BO\r\n\r\nbusiness object：业务对象\r\n\r\nBO把业务逻辑封装为一个对象。\r\n\r\n我理解是PO的组合，比如投保人是一个PO，被保险人是一个PO，险种信息是一个PO等等，他们组合起来是第一张保单的BO。\r\n\r\n\r\n\r\n## POJO\r\n\r\nplain ordinary java object：简单无规则java对象\r\n\r\n纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法。\r\n\r\n可以转化为PO、DTO、VO；比如POJO在传输过程中就是DTO。\r\n\r\n\r\n\r\n## DAO\r\n\r\ndata access object：数据访问对象\r\n\r\n主要用来封装对数据的访问，注意，是对数据的访问，不是对数据库的访问。\r\n\r\n\r\n其他的还有model/module/domain/entity什么的...等我再总结总结...', '2020-06-11 05:08:30', 'Java基础知识', 'https://images.unsplash.com/photo-1591643529995-aef2e1e6f281?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', '基础知识（一）', '2020-06-11 05:13:18', 5, 59, 1, 0);
INSERT INTO `t_blog` VALUES (66, b'0', b'0', '# 删除JDK\r\n\r\n1. 删除Java安装目录\r\n2. 删除环境变量JAVA_HOME\r\n3. 删除Path下关于java的目录\r\n4. 命令行检查 java-version\r\n\r\n# 安装JDK\r\n\r\n1. Oracle下载jdk1.8\r\n2. 同意协议\r\n3. 下载电脑对应版本\r\n4. 安装\r\n5. 记住安装路径\r\n6. 配置环境变量\r\n   1. 我的电脑---->环境变量JAVA_HOME\r\n   2. path变量\r\n\r\n', '2020-06-11 05:15:07', 'Java重新安装小结01', 'https://images.unsplash.com/photo-1433838552652-f9a46b332c40?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '原创', b'1', b'0', b'0', 'Java重新安装小结01', '2020-06-11 12:08:23', 1, 59, 1, 0);
INSERT INTO `t_blog` VALUES (67, b'1', b'1', '## 1.1什么是JavaScript？\r\n\r\nJavaScript是一门世界上最流行的脚本语言\r\n\r\njava、JavaScript\r\n\r\nJavaScript开发10天\r\n==一个合格的后端人员,必须**精通**JavaScript==\r\n\r\n> 甚至不需要精通Java\r\n\r\n## 1.2 历史\r\n\r\nECMAScript:它可以理解为是JavaScript的一个标准\r\n\r\n最新一已经到ES6版本了\r\n\r\n但是大部分六看清还只停留在支持ES5代码上;\r\n\r\n==开发环境---线上环境,版本不一致;==\r\n\r\n> Java中的概念:\r\n> 关键字;变量;流程控制;对象;数组;结构;闭包\r\n\r\n# 2.快速入门\r\n\r\n## 2.1 引入JavaScript\r\n\r\n### 1.内部标签\r\n\r\n```html\r\n<!--内部标签-->\r\n<script>\r\n    alert(\'hello world\');\r\n</script>\r\n```\r\n\r\n### 2.外部引入\r\n\r\nqj.js\r\n\r\n```JavaScript\r\nalert(\'hello world\');\r\n```\r\n\r\nindex.html\r\n\r\n```html\r\n<script src=\"js/qj.js\"></script>\r\n```\r\n\r\n测试代码\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title>Title</title>\r\n        <!--script标签内,写JavaScript代码-->\r\n\r\n        <!--内部标签-->\r\n        <!--<script>-->\r\n        <!--    alert(\'hello world\');-->\r\n        <!--</script>-->\r\n\r\n        <!--外部引入-->\r\n        <!--注意:script必须成对出现-->\r\n        <script src=\"js/qj.js\"></script>\r\n\r\n        <!--默认也是text/javascript-->\r\n        <script type=\"text/javascript\">\r\n\r\n        </script>\r\n\r\n    </head>\r\n    <body>\r\n\r\n    </body>\r\n</html>\r\n```\r\n\r\n## 2.2 基本语法入门\r\n\r\n浏览器必备调试须知：\r\n\r\n![image-20200416111709099](image-20200416111709099.png)\r\n\r\n```html\r\n<!--JavaScript严格区分大小写-->\r\n<script>\r\n    // 1.定义变量 Java中:变量类型 变量名=变量值;\r\n    //           JavaScript中 变量类型只有 var\r\n    var num = 1;\r\n    // alert(num);\r\n    // 2.条件控制\r\n    var score=65;\r\n    if(score>60 && score<70){\r\n        alert(\"60-70\");\r\n    }else if (score>70 && score<80){\r\n\r\n    }else{\r\n        alert(\"other\");\r\n    }\r\n    //console.log(score)在浏览器的控制台打印印相对于sout\r\n\r\n</script>\r\n```\r\n\r\n## 2.3 数据类型\r\n\r\n数值；文本；图形；音频；视频\r\n\r\n==变量==\r\n\r\n```JavaScript\r\n/*不能以数字开头*/\r\nvar a1\r\n```\r\n\r\n\r\n\r\n==number==\r\n\r\nJS不区分整数小数，Number\r\n\r\n```javascript\r\n123//整数\r\n123.1//浮点数\r\n1.123e3//科学技术法\r\n-99//复数\r\nNaN//not a Number\r\nInfinity//无限大\r\n```\r\n\r\n==字符串==\r\n\r\n\'abc\' 	\"abc\"  \'\\n\'\r\n\r\n==布尔值==\r\n\r\ntrue；\r\n\r\nfalse；\r\n\r\n==逻辑运算==\r\n\r\n```java\r\n&& 与  全真为真;\r\n|| 或  一真则真;\r\n!  非  真假互换;\r\n```\r\n\r\n**==比较运算符==**\r\n\r\n```java\r\n= 赋值;\r\n== 等于（类型不一样，值一样，也是真）;\r\n=== 绝对等于 (类型，值，都一样才真)\r\n```\r\n\r\n这是JS的缺陷，坚持不要使用==比较；\r\n\r\n须知，\r\n\r\n* NaN===NaN，这个与所有的数值都不相等，包括自己；\r\n* 只能通过isNaN（NaN）来判断这个数是不是NaN；\r\n\r\n浮点数问题：\r\n\r\n```java\r\nconsole.log((1/3)===(1-2/3));//精度损失，不相等\r\n```\r\n\r\n尽量避免浮点数运算，存在精度问题！\r\n\r\n==null 和 undefined==\r\n\r\n* null空\r\n* undefined 未定义\r\n\r\n==数组==\r\n\r\n一系列相同类型的对象\r\n\r\n```JavaScript\r\nvar arr=[1,2,3,4,5,6,\'hello\',null,true];\r\n/*支持new关键字,但是不建议使用这种方式*/\r\nnew Array(1,2,3,4,5,6,\'hello\',null,true);\r\n```\r\n\r\n**取数组下标:如果越界了;就会undefined**\r\n\r\n==对象==\r\n\r\n对象大括号:{	}\r\n\r\n数组中括号:[	]\r\n\r\n> 每个属性之间用逗号\",\"分隔最后一个不需要添加\r\n\r\n## 2.4 严格检查模式\r\n\r\n严格检查模式开启;前提IDE支持ES6语法;必须写在scrip第一行\r\n\r\n```JavaScript\r\n<script>\r\n    // 严格检查模式开启;前提IDE支持ES6语法;必须写在scrip第一行\r\n    \'use strict\';\r\n// 全局变量,避免使用\r\ni = 1;\r\n// 局部变量\r\nlet a = 1;\r\n\r\n</script>\r\n```\r\n\r\n# 3.数据类型\r\n\r\n## 3.1字符串\r\n\r\n### 1.正常字符串我们用单引号或者双引号包裹\r\n\r\n### 2.注意转义字符 \\\r\n\r\n```java\r\n\\\';\r\n\\t;\r\n\\n;\r\n\\u4e2d; \\u#### Unicode字符;\r\n\\x41 Ascll字符\r\n```\r\n\r\n3. ### 多行字符串编写\r\n\r\n使用 `键 ESC下面Tab上面\r\n\r\n```JavaScript\r\nvar msg=`\r\nhello\r\n你好\r\nword`\r\n```\r\n\r\n### 4.模板字符串\r\n\r\n```JavaScript\r\n<script>\r\n    \'use strict\';\r\nlet name=\"于谦\"\r\nlet age=3;\r\nlet msg=`你好呀,${name}`\r\n</script>\r\n```\r\n\r\n### 5.字符串长度\r\n\r\n```JavaScript\r\nconsole.log(student.length);\r\n```\r\n\r\n### 6.字符串不可变\r\n\r\n![image-20200416125512925](image-20200416125512925.png)\r\n\r\n### 7.大小写转换\r\n\r\n```JavaScript\r\n//注意这里是方法不是属性了;\r\nstudent.toUpperCase();\r\nstudent.toLowerCase();\r\n```\r\n\r\n### 8.student.indexOf(\'t\')\r\n\r\n### 9.substring\r\n\r\n```JavaScript\r\n[)\r\n student.substring(1)//截取从第一个字符串到最后一个字符串\r\n student.substring(1,3)// 包头不包尾[包含第一个不含第三个)\r\n```\r\n\r\n## 3.2 数组\r\n\r\nArray可以包含任意的数据类型\r\n\r\n```JavaScript\r\nvar arr=[1,2,3,4,5,6] // 通过下标取值和赋值\r\narr[0]\r\narr[0] =1;\r\n```\r\n\r\n### 1.长度\r\n\r\n```JavaScript\r\narr.length\r\n```\r\n\r\n注意:给arr.length赋值.数组大小会发生电话~如果赋值过小;元素就会丢失\r\n\r\n### 2.indexOf\r\n\r\n通过元素获得下标索引\r\n\r\n```JavaScript\r\narr.indexOf(2)\r\n1\r\n```\r\n\r\n字符串的\"1\"和数字 1是不同的\r\n\r\n### 3.slice()\r\n\r\n截取Arry的一部分,返回一个新数组;\r\n\r\n类似于String中的substring()\r\n\r\n### 4.push(),pop()尾部\r\n\r\n```JavaScript\r\npush();压入到尾部\r\npop();弹出尾部的一个元素\r\n```\r\n\r\n### 5.unshift();shift() 头部\r\n\r\n```JavaScript\r\nunshift(); 压入到头部\r\nshift();弹出头部的一个元素\r\n```\r\n\r\n\r\n\r\n### 6.排序sort()\r\n\r\n```JavaScript\r\n(3) [\"b\",\"a\",\"c\"];\r\narr.sort();\r\n(3) [\"a\",\"b\",\"c\"];\r\n```\r\n\r\n### 7.元素翻转 reverse()\r\n\r\n```JavaScript\r\n(3) [\"a\",\"b\",\"c\"];\r\narr.reverse();\r\n(3) [\"c\",\"b\",\"a\"];\r\n```\r\n\r\n### 8.concat();\r\n\r\n```javascript\r\n(3) [\"c\",\"b\",\"a\"];\r\narr.concat([1,2,3]);\r\n(6)[\"c\",\"b\",\"a\",1,2,3]\r\narr\r\n(3) [\"c\",\"b\",\"a\"];\r\n```\r\n\r\n**注意:concat();不会修改数组;只是产生一个新数组**\r\n\r\n### 9.连接符 join\r\n\r\n打印拼接数组,使用特殊的字符串连接\r\n\r\n```JavaScript\r\n(3) [\"C\", \"B\", \"A\"]\r\narr.join(\'-\')\r\n\"C-B-A\"\r\n```\r\n\r\n### 10.多维数组\r\n\r\n```JavaScript\r\narr = [[1,2],[3,4],[5,6]];\r\narr[1][1]\r\n4\r\n```\r\n\r\n**数组:存储数据(知道:如何存,怎样取---->方法可以自己写)**\r\n\r\n## 3.3 对象\r\n\r\n若干键值对\r\n\r\n```JavaScript\r\nvar 对象名={\r\n    属性名:属性值,\r\n    属性名:属性值,\r\n    属性名:属性值,\r\n    属性名:属性值\r\n}\r\n//定义了一个person对象,他有四个属性值\r\nvar person = {\r\n    name: \"于谦\",\r\n    age: 48,\r\n    email: \"yuqian@139.com\",\r\n    score: 0\r\n}\r\n```\r\n\r\n\r\n\r\nJS中的对象用,{...}表示一个对象,键值对描述属性 XXX:XXX,多个属性之间使用逗号隔开,最后一个属性不加逗号\r\n\r\n**==JavaScript中的所有的键都是字符串;值是任意对象==**\r\n\r\n### 1.对象赋值\r\n\r\n```JavaScript\r\nperson.name=\"郭德纲\"\r\n\"郭德纲\"\r\nperson.name\r\n\"郭德纲\"\r\n```\r\n\r\n### 2.使用一个不存在的对象属性不会报错!undefined---未定义\r\n\r\n```JavaScript\r\nperson.haha\r\nundefined\r\n```\r\n\r\n### 3.动态删减属性\r\n\r\n```javascript\r\ndelete person.name\r\ntrue\r\nperson\r\n{age: 48, email: \"yuqian@139.com\", score: 0}\r\n```\r\n\r\n### 4.动态添加\r\n\r\n```JavaScript\r\nperson.haha=\"haha\"\r\n\"haha\"\r\nperson\r\n{age: 48, email: \"yuqian@139.com\", score: 0, haha: \"haha\"}\r\n```\r\n\r\n### 5.判断属性值是否在这个对象中  XXX in XXX\r\n\r\n**==JavaScript中的所有的键都是字符串;值是任意对象==**\r\n\r\n所以age加==\' \'==\r\n\r\n```JavaScript\r\n\'age\' in person\r\ntrue\r\n// 继承\r\n\'toString\' in person\r\ntrue\r\n```\r\n\r\n### 6.判断一个属性是不是自身拥有的 hasOwnProperty()\r\n\r\n```JavaScript\r\nperson.hasOwnProperty(\'age\')\r\ntrue\r\nperson.hasOwnProperty(\'toString\')\r\nfalse\r\n```\r\n\r\n\r\n\r\n## 3.4 流程控制\r\n\r\n### 1.while循环,注意避免程序死循环\r\n\r\n```JavaScript\r\n\"use strict\";\r\nvar age=3;\r\nwhile(age<100){\r\n    age=age+1;\r\n    console.log(age);\r\n}\r\n// do while \r\ndo {\r\n    age=age+1;\r\n    console.log(age);\r\n}while(age<100);\r\n```\r\n\r\n### 2.for循环\r\n\r\n```JavaScript\r\nfor (let i=0;i<100;i++){\r\n    console.log(i);\r\n}\r\n```\r\n\r\n### 3.forEach\r\n\r\n```JavaScript\r\nage.forEach(function (value) {\r\n    console.log(value);\r\n})\r\n\r\n```\r\n\r\n\r\n\r\n### 4.for...in\r\n\r\n```JavaScript\r\n//这里的 num 是一个索引下标\r\n//for (var index in object){}\r\nfor (var num in age){\r\n    console.log(age[num]);\r\n}\r\n```\r\n\r\n## 3.5 Map和Set\r\n\r\n> **ES6的新特性**\r\n\r\n```JavaScript\r\nvar map = new Map([[\'Tom\', 100], [\'Jack\', 90], [\'Hu\', 80]]);\r\nvar name=map.get(\'Tom\');// 通过key获得value\r\nmap.set(\'admin\',123456)//新增或者修改\r\nconsole.log(name);\r\nmap.delete(\'Tom\');//删除\r\n```\r\n\r\nconsole\r\n\r\n```JavaScript\r\nmap\r\nMap(4) {\"Tom\" => 100, \"Jack\" => 90, \"Hu\" => 80, \"admin\" => 123456}\r\n\r\nMap(3) {\"Jack\" => 90, \"Hu\" => 80, \"admin\" => 123456}\r\n```\r\n\r\nSet:无序不重复的集合\r\n\r\n```JavaScript\r\n// Set\r\nvar set = new Set([3, 11, 11, 11, 11]);// set可以去重\r\nset.add(2);//添加\r\nset.delete(11)//删除\r\nconsole.log(set.has(3));//判断是否包含\r\n```\r\n\r\n```JavaScript\r\nSet(2) {3, 2}\r\ntrue\r\n```\r\n\r\n## 3.6 iterator\r\n\r\n> 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\r\n>\r\n> 　　Java中的Iterator功能比较简单，并且只能单向移动：\r\n>\r\n> 　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\r\n>\r\n> 　　(2) 使用next()获得序列中的下一个元素。\r\n>\r\n> 　　(3) 使用hasNext()检查序列中是否还有元素。\r\n>\r\n> 　　(4) 使用remove()将迭代器新返回的元素删除。\r\n>\r\n> 　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。\r\n\r\n> ### Iterator的三个主要方法\r\n>\r\n> #### 1.1 Boolean hasNext();\r\n>\r\n> 判断 iterator 内是否存在下1个元素，如果存在，返回true，否则返回false。（注意，这时上面的那个指针位置不变）\r\n>\r\n> #### 1.2 Object next();\r\n>\r\n> 返回 iterator 内下1个元素，同时上面的指针向后移动一位。\r\n> 故，如果不断地循环执行next()方法，就可以遍历容器内所有的元素了。\r\n>\r\n> #### 1.3 void remove();\r\n>\r\n> 删除 iterator 内指针的前1个元素，前提是至少执行过1次next();\r\n> (这个方法不建议使用，建议使用容器本身的romove 方法)\r\n>\r\n> 在Java的各种容器中，例如ArrayList，HashSet等，并没有直接实现Iterator这个接口。所以ArrayList，HashSet容器内是没有hasnext()，next()的方法的，而是iterator() 这个方法，返回1个实现了Iterator接口的iterator对象。\r\n\r\n\r\n\r\n```JavaScript\r\n//for of 输出具体值(而不是下标索引)\r\n//for in 输出下标索引\r\n\"use strict\";\r\nlet arr=[3,4,5];\r\narr.name=\"213\";  //新增的数据,for in不会改变下标,早期的一个bug;所以尽量使用for of\r\n// 0\r\n// 1\r\n// 2\r\n// name\r\nfor (var x of arr){\r\n    console.log(x);\r\n}\r\n// 遍历数组\r\nvar map=new Map([[\"tom\",100],[\"Jack\",90],[\"Hu\",80]]);\r\nfor (let x of map){\r\n    console.log(x);\r\n}\r\n//遍历set\r\nvar set = new Set([5,6,7]);\r\nfor (let x of set){\r\n    console.log(x);\r\n}\r\n```\r\n\r\n\r\n\r\n# 4.函数\r\n\r\n方法和函数的区别\r\n\r\n* 对象中:方法\r\n* 对象外:函数\r\n\r\n## 4.1定义函数\r\n\r\n```java\r\n// java函数\r\npublic 返回值类型 方法名{\r\n    方法体;\r\n}\r\n```\r\n\r\n```JavaScript\r\nfunction abs(){\r\n    if(x>=0){\r\n        return x;\r\n    }else {\r\n        return -x;\r\n    }\r\n}\r\n```\r\n\r\n```javascript\r\n//结果\r\nabs();\r\nNaN\r\n```\r\n\r\n一旦执行到return代表函数结束,返回结果;\r\n\r\n如果没有执行return,函数执行完也返回结果,结果一般是undefine或者NaN\r\n\r\n> 定义方式二\r\n\r\n```JavaScript\r\nvar abs=function(x){\r\n        if(x>=0){\r\n        return x;\r\n    }else {\r\n        return -x;\r\n    }\r\n}\r\n```\r\n\r\nfunction(x){....}匿名函数,但是可以把结果赋值给abs,通过abs可以调用函数.\r\n\r\n方式一和方式二等价\r\n\r\n> 调用函数\r\n\r\n```JavaScript\r\nabs(10)//10\r\nabs(-10)//10\r\n```\r\n\r\nJavaScript可以传递参数,也可以不传递参数;\r\n\r\n> arguments\r\n>\r\n> Javascrip中每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式\"[ ]\"引用arguments的元素。\r\n\r\n* ==arguments==是一个JS免费赠送的关键词\r\n\r\n* 代表传递出来的所有参数是一个数组\r\n\r\n问题,arguments会包含所有参数,有时候我们想要使用多余的参数进行附加操作,需要排除已有参数\r\n\r\n> rest---ES6新特性\r\n\r\n以前要使用多余参数:\r\n\r\n```JavaScript\r\n    function aaa(a,b){\r\n        console.log(\"a=>\"+a);\r\n        console.log(\"b=>\"+b);\r\n        if (arguments.length>2){\r\n            for (var i=2;i<=arguments.length;i++){\r\n                方法体;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n现在使用   ...rest\r\n\r\n```javascript\r\nfunction aaa(a,b,...rest){\r\n    console.log(\"a=>\"+a);\r\n    console.log(\"b=>\"+b);\r\n    console.log(rest);\r\n}\r\n```\r\n\r\nrest参数只能写在最后面,必须使用==...==标识\r\n\r\n测试\r\n\r\n```java\r\n	aaa(1)\r\n    a=>1\r\n    b=>undefined\r\n    undefined\r\n    aaa(1,12)\r\n    a=>1\r\n    b=>12\r\n    undefined\r\n    aaa(1,12,132,123,12364,456879)\r\n    a=>1\r\n    b=>12\r\n    (4) [132, 123, 12364, 456879]\r\n    undefined\r\n```\r\n\r\n## 4.2变量作用域\r\n\r\n在JavaScript中, var定义变量实际上是有作用域的\r\n\r\n假设在函数体中声明,则在函数体外不能使用,(假如想用,后面可以学习使用==闭包==)\r\n\r\n内部函数可以使用外部成员变量,反之则不行.\r\n\r\n```JavaScript\r\n  function qj() {\r\n        var x = 1;\r\n\r\n        function qj2() {\r\n            var y = x + 1;// 2\r\n        }\r\n\r\n        var z = y + 1; // Uncaught ReferenceError: y is not defined\r\n    }\r\n```\r\n\r\n假设内部函数变量与外部函数变量重名!\r\n\r\n```javascript\r\nfunction qj1() {\r\n        var x = 1;\r\n\r\n        function qj3() {\r\n            var x = \'A\'\r\n            console.log(\'inner\'+x);\r\n        }\r\n        console.log(\'outer\'+x);\r\n        qj3();\r\n    }\r\nqj1();\r\n```\r\n\r\nJavaScript总共的函数查找变量从自身开始,由内向外查找;\r\n\r\n假设外部存在同名变量,内部函数就会屏蔽这个同名变量\r\n\r\n\r\n\r\n> 提升变量作用域\r\n\r\n```JavaScript\r\nfunction qj4(){\r\n    var x =\"x\"+y;\r\n    console.log(x);\r\n    var y=\'y\'\r\n}\r\n```\r\n\r\n结果:x undefined ,x产生但是未赋值\r\n\r\n> 上面==等价于==\r\n\r\n```JavaScript\r\n//等价于\r\nfunction qj4(){\r\n    var y;\r\n    var x =\"x\"+y;\r\n    console.log(x);\r\n    var y=\'y\'\r\n    }\r\n```\r\n\r\n说明JS执行引擎,自动提升了y的声明位置,但是不会提升y的赋值位置;\r\n\r\n这是JS建立之初就存在的特性,所有尽量把所有的变量定义在最前面;不要乱放,便于维护.\r\n\r\n> 全局函数\r\n\r\n```javascript\r\n//全局变量\r\nx = 1;\r\n\r\nfunction f() {\r\n    console.log(x);\r\n}\r\n\r\nf();\r\nconsole.log(x);\r\n```\r\n\r\n严格检查模式下是错误的,避免使用;\r\n\r\n全局对象window\r\n\r\n```JavaScript\r\nvar x=\'xxx\';\r\nalert(x);\r\nalert(window.x);//默认全局变量都会自动绑定在window对象下\r\n```\r\n\r\nalert()这个函数本身也是==window==的变量\r\n\r\n```JavaScript\r\nvar x=\'xxx\';\r\nwindow.alert(x);\r\nvar old_alert =window.alert;\r\n//old_alert\r\nwindow.alert =function(){};\r\n//发现alert()失效\r\nwindow.alert(123);\r\n//恢复\r\nwindow.alert=old_alert;\r\nwindow.alert(456);\r\n```\r\n\r\n说明JavaScript实际上只有一个全局作用域,任何变量(函数也可以视为一个变量),假设函数作用域范围内找到,就会向往外查找,如果在window也找不到,就会报错==RefrenceError==\r\n\r\n> 规范\r\n\r\n由于所有的全局变量都会绑定到window上,如果不同的js文件,使用相同的全局变量就会产生冲突;\r\n\r\n冲突---->如何避免冲突?\r\n\r\n> 把自己定义的变量.绑定到自己定义的唯一空间名字中,降低命名冲突问题;\r\n\r\n```JavaScript\r\n//定义自己的唯一全局变量命名空间\r\nvar HUapp={};\r\n//定义自己全局变量\r\nHUapp.name=\'胡\';\r\nHUapp.add=function(a,b){\r\n    return a+b;\r\n}\r\n```\r\n\r\n==JQuery就是这样做的,并且jQuery等价于${}==\r\n\r\n> 局部作用域 let\r\n\r\n```JavaScript\r\nfunction aaa(){\r\n    for (var i=0;i<100;i++){\r\n        console.log(i);\r\n    }\r\n    console.log(i+1);//问题:这个i作用域外还可以使用\r\n}\r\n```\r\n\r\nES6 let关键字解决局部作用域冲突问题-----建议使用let\r\n\r\n> 常量 const  (只读变量)\r\n\r\n在ES6之前:只要用全是大写英文字母命名的变量就是常量,建议不要修改这样的值(实际上能被修改)\r\n\r\n```JavaScript\r\nvar PI=\'3.14\';//约定全大写字母为常量;建议不许修改\r\nconsole.log(PI);\r\nPI=\'213\';\r\nconsole.log(PI);//实际上可以改变\r\n```\r\n\r\nES6引入常量关键字:==const== -----只读变量\r\n\r\n```JavaScript\r\nconst PI1=\'3.14\';\r\nconsole.log(PI1);\r\nPI1=\'131\';//Uncaught TypeError: Assignment to constant variable\r\nconsole.log(PI1);\r\n```\r\n\r\n## 4.3方法\r\n\r\n> 定义方法\r\n\r\n方法就是把函数放入对象内部,对象只有两个东西:属性,方法;\r\n\r\n```JavaScript\r\nvar kuangshen ={\r\n    name:\'秦疆\',\r\n    birth:1998,\r\n    age:function(){\r\n        var now=new Date().getFullYear();\r\n        return now-this.birth;\r\n    }\r\n}\r\n//属性\r\nkuangshen.name\r\n//方法一定要带()\r\nkuangshen.age();\r\n```\r\n\r\n\r\n\r\n```JavaScript\r\nfunction getAge() {\r\n        //今年年份-出生年份\r\n        var now=new Date().getFullYear();\r\n        return now-this.birth;\r\n}\r\nvar kuangshen ={\r\n    name:\'秦疆\',\r\n    birth:1998,\r\n    age:getAge\r\n}\r\n//kuangshen.getAge成功\r\n//getAge() NaN ----window没有this.birth\r\n```\r\n\r\n结论:this是无法只想的,默认指向调用它的那个对象;\r\n\r\n> apply\r\n\r\nJS可以通过apply使得this可以指向一个对象;\r\n\r\n```JavaScript\r\ngetAge().apply(kuangshen,[]);//表示 this指向kuangshen,参数为空\r\n```\r\n\r\n# 5.内部对象\r\n\r\n> 标准对象\r\n\r\n```JavaScript\r\ntypeof 123\r\n\"number\"\r\ntypeof \'123\'\r\n\"string\"\r\ntypeof true\r\n\"boolean\"\r\ntypeof NaN\r\n\"number\"\r\ntypeof []\r\n\"object\"\r\ntypeof {}\r\n\"object\"\r\ntypeof Math.abs\r\n\"function\"\r\ntypeof undeifined\r\n\"undeifined\"\r\n```\r\n\r\n\r\n\r\n## 5.1 Date\r\n\r\n```javascript\r\nvar now =new Date();// Fri Apr 17 2020 18:39:26 GMT+0800 (中国标准时间)\r\nnow.getFullYear();// 年\r\nnow.getMonth();// 月\r\nnow.getDate(); // 日\r\nnow.getDay(); // 星期几\r\nnow.getHours(); // 时\r\nnow.getMinutes(); // 分\r\nnow.getSeconds(); // 秒\r\nnow.getTime(); // 时间戳,全世界统一 1970.1.1 00:00:00毫秒开始\r\n```\r\n\r\n\r\n\r\n```javascript\r\nconsole.log(new Date(1587120159785)); //时间戳转回时间\r\n// 结果:Fri Apr 17 2020 18:42:39 GMT+0800 (中国标准时间)\r\nconsole.log(now.toLocaleDateString());\r\nconsole.log(now.toLocaleTimeString());\r\nconsole.log(now.toLocaleString());\r\n```\r\n\r\n## 5.2  JSON\r\n\r\n> JSON是什么?\r\n\r\n* JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。\r\n* 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。\r\n* 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率\r\n\r\n在JavaScript中一切皆对象,任何JS支持的类型都可以使用JSON来表示;\r\n\r\n格式:\r\n\r\n* 对象用{}\r\n* 数组用[]\r\n* 所有的键值对都使用 key:value\r\n\r\nJSON和JS对象的转换\r\n\r\n```JavaScript\r\n\"use strict\";\r\nlet user = {\r\n    name: \"秦疆\",\r\n    age: 23,\r\n    sex: \"男\"\r\n};\r\n\r\n// 对象转换为JSON字符串 {\"name\":\"秦疆\",\"age\":23,\"sex\":\"男\"}\r\nlet jsonUser = JSON.stringify(user);\r\n\r\n//json 字符串转化为对象 参数为json字符串\r\nlet obj = JSON.parse(\'{\"name\": \"秦疆\", \"age\": 23, \"sex\": \"男\"}\')\r\n```\r\n\r\n分多人分不清楚，JSON和JS对象的区别\r\n\r\n```JavaScript\r\nvar obj={a:\'hello\',b:\'hellob\'};\r\nvar json=\'{\"a\":\"hello\",\"b\":\"hellob\"}\'\r\n```\r\n\r\n## 5.3 Ajax\r\n\r\n* 原生的js写法 xhr异步请求\r\n* JQuery封装好的方法 $(\"#name\"),ajax(\"\")\r\n* axios 请求\r\n\r\n\r\n\r\n# 6.面向对象编程\r\n\r\n## 6.1 什么是面向对象\r\n\r\nJava JavaScript C#.....面向对象;JavaScript有一些区别!\r\n\r\n* 类:模板\r\n* 对象:具体的实例\r\n\r\n在JavaScript中\r\n\r\n原型---类似于父类\r\n\r\n```JavaScript\r\n\"use strict\";\r\nlet user = {\r\n    name: \"秦疆\",\r\n    age: 23,\r\n    sex: \"男\",\r\n    run: function () {\r\n        console.log(this.name + \" \" + \"is\" + \" \" + \"running....\")\r\n    }\r\n};\r\n\r\nvar xiaoming = {\r\n    name: \"xiaoming\"\r\n};\r\n\r\n//原型对象\r\n// xiaoming.__proto__ = user;\r\n\r\nvar Bird = {\r\n    fly: function () {\r\n        console.log(this.name + \" \" + \"is\" + \" \" + \"flying....\")\r\n    }\r\n};\r\nxiaoming.__proto__ =Bird;\r\n```\r\n\r\n> class 继承\r\n\r\n==class==关键字,是在ES6引入的\r\n\r\nES6之前,要给一个原型添加方法\r\n\r\n```JavaScript\r\nfunction Student(name){\r\n    this.name=name;\r\n}\r\n//给student原型新增一个方法---从原型对象添加\r\n//直接在student中写也可以但是其他的同类型无法继承\r\nStudent.prototype.hello=function(){\r\n    alert(\'hello\')\r\n}\r\n```\r\n\r\nES6之后用class关键字添加\r\n\r\n1. 顶一个类,属性,方法.\r\n\r\n```JavaScript\r\nclass Student{\r\n    constructor(name){\r\n        thisname=name\r\n    }\r\n    hello(){\r\n        alert(\'hello\')\r\n    }\r\n}\r\nvar xiaoming = new Student(\"xiaoming\");\r\nvar xiaohong = new Student(\"xiaohong\");\r\nxiaoming.hello();\r\n```\r\n\r\n2.继承\r\n\r\n```JavaScript\r\nclass Student {\r\n    constructor(name) {\r\n        this.name = name\r\n    }\r\n\r\n    hello() {\r\n        alert(\'hello\')\r\n    }\r\n}\r\n\r\nclass pupil extends Student {\r\n    constructor(name, grade) {\r\n        super(name);\r\n        this.grade = grade;\r\n    }\r\n\r\n    myGrade() {\r\n        alert(\"我是一名小学生\");\r\n    }\r\n}\r\n\r\nvar xiaoming = new Student(\"xiaoming\");\r\nvar xiaohong = new pupil(\"xiaohong\", 100);\r\n```\r\n\r\n本质:查看对象原型\r\n\r\n![image-20200417201324967](image-20200417201324967.png)\r\n\r\n> 原型链----------链成圆\r\n\r\n![image-20200417201624380](image-20200417201624380.png)\r\n\r\n# ==7.操作BOM对象(重点)==\r\n\r\n> 浏览器介绍\r\n\r\nJavaScript和浏览器的关系?\r\n\r\nJavaScript的诞生就是为了让他能在浏览器中运行!\r\n\r\nBOM:浏览器对象模型\r\n\r\n* IE6~11\r\n* chrome\r\n* Safari\r\n* Firefox[Liunx内置]\r\n* Opera\r\n\r\n>window \r\n\r\nwindow代表浏览器窗口\r\n\r\n![image-20200417210643835](image-20200417210643835.png)\r\n\r\n> Navigator---网景公司的浏览器--==不建议使用==\r\n\r\nNavigator封装了浏览器的信息\r\n\r\n![image-20200417210822326](image-20200417210822326.png)\r\n\r\n大多数时候,我们不会使用==navigator==对象,因为会被认为修改!\r\n\r\n不建议使用这些属性来判断和编写代码\r\n\r\n> screen\r\n\r\n![image-20200417211035718](image-20200417211035718.png)\r\n\r\n> ==location(重要)==\r\n\r\nlocation 代表当前页面的URL信息\r\n\r\n```JavaScript\r\nhost:\"www.baidu.com\"\r\nhref:\"https://www.baidu.com\"\r\nprotocol:\"https:\"\r\nreload:f reload()//刷新网页\r\n//设置新地址\r\nlocation.assign(\'https://360.com\')\r\n```\r\n\r\n> document\r\n\r\ndocument代表当前页面,HTML DOM文档树\r\n\r\n```JavaScript\r\ndocument.title\r\n\"百度一下,你就知道\"\r\n//修改标题\r\ndocument.title=\'狂神说\'\r\n\"狂神说\"\r\n```\r\n\r\n获取具体的文档树节点\r\n\r\n```JavaScript\r\n<dl id=\"app\">\r\n    <dt>Java</dt>\r\n<dd>JavaSE</dd>\r\n<dd>JavaEE</dd>\r\n</dl>\r\n<script>\r\n    var dl =document.getElementById(\'app\');\r\n</script>\r\n```\r\n\r\n可以获得网页的cookie\r\n\r\n```JavaScript\r\ndocument.cookie\r\n```\r\n\r\n服务器端可以设置cookie为httpOnly保护cookie\r\n\r\n> history---==(不建议使用)==\r\n\r\n```javascript\r\nhistory.back();//后退\r\nhistory.forward();//前进\r\n//实际上是历史记录\r\n```\r\n\r\n# 8.Dom 对象 (重点)\r\n\r\n\r\n\r\nDom:文档对象模型\r\n\r\n> 核心\r\n\r\n浏览器网页就是一个Dom树型结构\r\n\r\n* 更新:更新Dom节点\r\n* 遍历Dom节点,得到Dom节点\r\n* 删除:删除一个Dom节点\r\n* 添加:添加一个新的节点\r\n\r\n要操作一个Dom节点,就必须获得这个Dom节点\r\n\r\n> 获得dom节点\r\n\r\n```JavaScript\r\nvar h1 = document.getElementsByName(\'h1\');\r\nvar p1 = document.getElementById(\'p1\');\r\nvar p2 = document.getElementsByClassName(\'p2\');\r\nvar father = document.getElementById(\'father\');\r\n\r\nvar childrens = father.children;//获取父节点下的子节点\r\n// father.firstChild;\r\n// father.lastChild;\r\n// p1.nextSibling;\r\n// p1.nextElementSibling;\r\n```\r\n\r\n\r\n\r\n> 更新节点\r\n\r\n```JavaScript\r\ndocument.getElementById(\'id1\');\r\n```\r\n\r\n操作文本\r\n\r\n* id1.innerText=\'456\'` 修改文本值\r\n* `id1.innerHTML=\'<strong>132</strong>\'`可以解析HTML标签\r\n\r\n操作CSS\r\n\r\n```JavaScript\r\nid1.style.color=\'red\';//属性使用引号包裹为字符串\r\nid1.style.padding=\'2em\'\r\nid1.style.fontSize=\'100px\';//驼峰命名问题\r\n```\r\n\r\n\r\n\r\n> 删除节点\r\n\r\n删除节点的步骤:\r\n\r\n1. 先获取父节点\r\n2. 通过父节点删除自己\r\n\r\n```JavaScript\r\n<script>\r\n    var h1 =document.getElementsByTagName(\'h1\');\r\nvar p1 =document.getElementById(\'p1\');\r\nvar p2 =document.getElementsByClassName(\'p2\');\r\nvar father=document.getElementById(\'father\');\r\n\r\nvar childrens =father.children;//获取父节点下所有子节点\r\n//删除步骤\r\nvar self =document.getElementById(\'p1\');//1.获得要删除的\r\nvar father =p1.parentElement;//2.找到要删除的节点的父节点\r\nfather.removeChild(self);//3.从父节点删除节点\r\n\r\n //删除是一个动态过程\r\n        father.removeChild(father.children[0]);\r\n        father.removeChild(father.children[1]);\r\n        father.removeChild(father.children[2]);//报错,没有第三个节点\r\n</script>\r\n<body>\r\n    <div id=\"father\">\r\n        <h1>标题1</h1>\r\n<p id=\"p1\">p1</p>\r\n<p class=\"p2\">p2</p>\r\n</div>\r\n</body>\r\n```\r\n\r\n\r\n\r\n==**注意删除多个节点的时候,children是时刻变化的,删除节点的时候一定要注意**==\r\n\r\n\r\n\r\n> 插入节点\r\n\r\n我们获得了某个dom节点,如果这个dom节点是空的,我没使用innerHTML就可以添加节点了\r\n但是如果有元素了就会覆盖;    \r\n\r\n所以我们一般使用追加节点来\r\n\r\n### 1.插入已有节点.\r\n\r\n```JavaScript\r\n//原始数据\r\n<body>\r\n    <p id=\"js\">JavaScript</p>\r\n<div id=\"list\">\r\n    <p id=\"se\">JavaSE</p>\r\n<p id=\"ee\">JavaEE</p>\r\n<p id=\"me\">JavaME</p>\r\n</div>\r\n<script>\r\n    var js=document.getElementById(\'js\');\r\nvar list=document.getElementById(\'list\');\r\n\r\n</script>\r\n</body>\r\n```\r\n\r\n```JavaScript\r\n//追加操作\r\nlist.appendChild(js);//已存在的节点\r\n```\r\n\r\n```html\r\n<!--操作结果-->\r\n<div id=\"list\">\r\n    <p id=\"se\">JavaSE</p>\r\n    <p id=\"ee\">JavaEE</p>\r\n    <p id=\"me\">JavaME</p>\r\n    <p id=\"js\">JavaScript</p>\r\n</div>\r\n```\r\n\r\n### 2.追加全新新节点\r\n\r\n1. 创建一个新节点\r\n2. 设置新节点属性\r\n3. 追加进入父标签\r\n\r\n```JavaScript\r\nvar newp=document.createElement(\'p\');//新建一个节点,类型是p\r\nnewp.id=\'newp\';//给新p设置ID属性\r\nnewp.innerText=\'hello word\';//设置显示的内容\r\nlist.appendChild(newp);//在list下追加newp\r\n```\r\n\r\n原始数据\r\n\r\n```html\r\n<div id=\"list\">\r\n    <p id=\"se\">JavaSE</p>\r\n    <p id=\"ee\">JavaEE</p>\r\n    <p id=\"me\">JavaME</p>\r\n</div>\r\n```\r\n\r\n追加结果显示\r\n\r\n```html\r\n<div id=\"list\">\r\n    <p id=\"se\">JavaSE</p>\r\n    <p id=\"ee\">JavaEE</p>\r\n    <p id=\"me\">JavaME</p>\r\n    <p id=\"newp\">hello word</p>\r\n</div>\r\n```\r\n\r\n追加标签节点\r\n\r\n```JavaScript\r\n//创建标签节点\r\nvar myScript =document.createElement(\'script\');\r\n//通过这个属性设置任意的属性值\r\nmyScript.setAttribute(\'type\',\'text/javascript\');\r\n```\r\n\r\n```JavaScript\r\n//玩\r\nvar body = document.getElementsByTagName(\'body\');//注意这里获得的是数组\r\n// body[0].style.backgroundColor=\'red\';\r\nbody[0].setAttribute(\'style\',\'background-color: yellow\');\r\n```\r\n\r\n> insert插入:\r\n\r\n# 9.操作表单(验证)\r\n\r\n### 1.表单是什么?\r\n\r\n> form DOM树种的节点\r\n\r\n* 文本框 text\r\n* 下拉框 select\r\n* 单选框 radio\r\n* 多选框CheckBox\r\n* 隐藏域 hidden\r\n* 密码框 password\r\n* ...........\r\n\r\n> 表单的目的:提交信息\r\n\r\n### 2.获得提交的新信息\r\n\r\n```html\r\n<form action=\"post\">\r\n    <p>\r\n        <span>用户名</span><input type=\"text\" id=\"username\" name=\"username\">\r\n    </p>\r\n    <p>\r\n        <!--多选框的值是设定好的value-->\r\n        <span>性别:</span>\r\n        <input type=\"radio\" name=\"sex\" value=\"man\" id=\"man\">男\r\n        <input type=\"radio\" name=\"sex\" value=\"women\" id=\"women\">女\r\n        <input type=\"radio\" name=\"sex\" value=\"secret\" id=\"secret\">秘密\r\n    </p>\r\n\r\n    <script>\r\n        var input_text = document.getElementById(\'username\');//获取节点\r\n        //得到输入框的值 JS代码input_text.value;这个只能获得当前值\r\n\r\n        var man_radio = document.getElementById(\'man\');//获取节点\r\n        var women_radio = document.getElementById(\'women\');//获取节点\r\n        var secret_radio = document.getElementById(\'secret\');//获取节点\r\n        man_radio.checked;//查看返回的结果是否为true,true被选中\r\n        // true  判断选中的标签\r\n        //women_radio.checked = true; 赋值操作单选框的焦点\r\n    </script>\r\n```\r\n\r\n### 3.提交表单 MD5加密密码 表单优化\r\n\r\n```html\r\n<body>\r\n    <!--表单绑定提交事件\r\nonsubmit绑定一个提交检测的函数\r\n返回一个true or false -->\r\n    <form action=\"https://www.baidu.com/\" method=\"post\" onsubmit=\"return ClickFunction()\">\r\n        <p>\r\n            <span>用户名:</span><input type=\"text\" id=\"username\" name=\"username\">\r\n        </p>\r\n        <p>\r\n            <!--输入的密码-->\r\n            <span>密码:</span><input type=\"password\" id=\"input-password\">\r\n        </p>\r\n        <input type=\"hidden\" id=\"md5-password\" name=\"password\">\r\n        <p>\r\n            <!--多选框的值是设定好的value-->\r\n            <span>性别:</span>\r\n            <input type=\"radio\" name=\"sex\" value=\"man\" id=\"man\">男\r\n            <input type=\"radio\" name=\"sex\" value=\"women\" id=\"women\">女\r\n            <input type=\"radio\" name=\"sex\" value=\"secret\" id=\"secret\">秘密\r\n        </p>\r\n        <p>\r\n            <!--<input type=\"submit\" value=\"点击提交\">-->\r\n            <input type=\"submit\" value=\"提交\">\r\n        </p>\r\n\r\n        <script>\r\n            var input_text = document.getElementById(\'username\');//获取节点\r\n            //得到输入框的值 JS代码input_text.value;这个只能获得当前值\r\n\r\n            var man_radio = document.getElementById(\'man\');//获取节点\r\n            var women_radio = document.getElementById(\'women\');//获取节点\r\n            var secret_radio = document.getElementById(\'secret\');//获取节点\r\n            man_radio.checked;//查看返回的结果是否为true,true被选中\r\n            // true  判断选中的标签\r\n            //women_radio.checked = true; 赋值操作单选框的焦点\r\n\r\n            function ClickFunction() {\r\n                var uname = document.getElementById(\'username\');\r\n                var pwd = document.getElementById(\'input-password\');\r\n                var md5pwd = document.getElementById(\'md5-password\');\r\n\r\n                md5pwd.value = md5(pwd.value);\r\n                //可以在return 校验判断表单内容\r\n                return true;\r\n            }\r\n        </script>\r\n        </body>\r\n```\r\n\r\n# 10.jQuery\r\n\r\nJavaScript\r\n\r\n jQuery\r\n\r\n> ```java\r\n> jQuery公式:\r\n> $(selector).action();\r\n> //使用jQuery之后\r\n> $(选择器).事件(方法(){\r\n> });\r\n> ```\r\n\r\n初试jQuery:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <!--方式一cdn jQuery 导入-->\r\n    <!--<script src=\"https://cdn.bootcss.com/jquery/3.5.0/jquery.js\"></script>-->\r\n    <!--方式二 jQuery文件导入项目-->\r\n    <script src=\"lib/jquery-3.4.1.js\"></script>\r\n</head>\r\n<body>\r\n<!--jQuery公式\r\n$(selector).action();\r\n-->\r\n\r\n<a href=\"\" id=\"test-jQuery\">点我</a>\r\n<script>\r\n    // 之前:var a document.getElementById(\'id\');\r\n    // a.click(function(){\r\n    // })\r\n\r\n    //使用jQuery之后\r\n    //$(选择器).事件(方法(){\r\n    // })\r\n    $(\'#test-jQuery\').click(function(){\r\n        alert(\'hello jQuery\');\r\n    })\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n## １.选择器\r\n\r\n```JavaScript\r\n//原生js,选择器少,麻烦不好记\r\n//标签\r\ndocument.getElementsByTagName();\r\n//id\r\ndocument.getElementById();\r\n//类\r\ndocument.getElementsByClassName();\r\n\r\n//jQuery\r\n$(\'标签\').click();//标签选择器\r\n$(\'#id\').click();//id选择器\r\n$(\'.class\').click();//class选择器\r\n```\r\n\r\njQuery文档工具栈:http://jquery.cuishifeng.cn\r\n\r\n## 2.事件\r\n\r\n```JavaScript\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <script src=\"lib/jquery-3.4.1.js\"></script>\r\n    <style>\r\n        #divMove{\r\n            width: 500px;\r\n            height: 500px;\r\n            border: 1px solid red;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<!--要求:获取鼠标当前的坐标-->\r\nmouse: <span id=\"mouseMove\"></span>\r\n<div id=\"divMove\">\r\n    在这里移动鼠标试一试\r\n</div>\r\n<script>\r\n    //当网页元素加载完毕,响应事件\r\n    //$(document).ready(function(){\r\n    //$(\'#divMove\').mousemove(function(e){\r\n    //$(\'#mouseMove\').text(\'x:\'+e.pageX+\'y:\'+e.pageY);\r\n	//})})\r\n    \r\n    //简化后:\r\n    $(function(){\r\n        $(\'#divMove\').mousemove(function(e){\r\n            $(\'#mouseMove\').text(\'x:\'+e.pageX+\'y:\'+e.pageY);\r\n        })\r\n    });\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 3.dom操作\r\n\r\n节点文本操作\r\n\r\n```JavaScript\r\n$(\'#test-ul li[name=python]\').text();//获得值\r\n$(\'#test-ul li[name=python]\').text(\'更新内容\');//重设值\r\n$(\'#test-ul\').html();//获得值\r\n$(\'#test-ul\').html(\'<strong>123</strong>\');//重设值\r\n```\r\n\r\n## 4.CSS操作\r\n\r\n```JavaScript\r\n$(\'#test-ul li[name=python]\').css({ \"color\": \"#ff0011\", \"background\": \"blue\" });\r\n```\r\n\r\n## 5.元素显示和隐藏\r\n\r\n本质: `display:none;`\r\n\r\n```JavaScript\r\n$(\'#test-ul li[name=python]\').show();//显示\r\n$(\'#test-ul li[name=python]\').hide();//隐藏\r\n```\r\n\r\n**未来ajax();**\r\n\r\n```JavaScript\r\n$.ajax({\r\n   type: \"POST\",\r\n   url: \"some.php\",\r\n   data: \"name=John&location=Boston\",\r\n   success: function(msg){\r\n     alert( \"Data Saved: \" + msg );\r\n   }\r\n});\r\n```\r\n\r\n# 11.学习小技巧\r\n\r\n1. 如何巩固js(看jQuery源码,看游戏源码!)\r\n2. 巩固HTML,CSS(扒网站,全都down下来,对应修改看效果)', '2020-06-11 05:17:34', '什么是JavaScript？', 'https://images.unsplash.com/photo-1507608443039-bfde4fbcd142?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'JavaScript学习', '2020-03-29 15:17:34', 2, 60, 1, 0);
INSERT INTO `t_blog` VALUES (68, b'1', b'1', '# 1.JavaWeb\r\n\r\n## 1.1Java Web前言\r\n\r\n### 1.基本概念\r\n\r\nweb开发:\r\n\r\n* web,网页的意思,\r\n* 静态web\r\n  * HTML,CSS\r\n  * 提供给所有人看的数据始终不会发生改变\r\n* 动态web\r\n  * 淘宝,几乎所有的网站\r\n  * 提供给所有人看到的数据始终会发生变化\r\n  * 技术栈:Servlet/JSP,ASP<PHP\r\n\r\n在Java中,动态web资源开发统称JavaWeb;\r\n\r\n## 1.2  Web应用程序\r\n\r\nweb应用程序:可以提供浏览器访问的程序;\r\n\r\n* a.html  b.html.....多个web资源,这些web可以被访问\r\n* 能访问到的任何一个页面或者资源,都存在于这个世界的某个计算机上\r\n* URL\r\n* 这个统一的web资源被放在同一个文件夹下,web应用程序---->Tomcat:服务器\r\n* 一个web应用程序分层多部分组成(静态web,动态web)\r\n  * html,css,js\r\n  * jsp,servlet\r\n  * java程序\r\n  * jar包\r\n  * 配置文件\r\n\r\nweb以心传心编写完毕后,弱项提供给外界访问,需要服务器统一管理\r\n\r\n## 1.3 静态web\r\n\r\n* *.html,*.htm这些都是网页的后缀,如果服务器上一直存在我们就可以直接读取\r\n\r\n![image-20200410183602021](D:\\file\\Typora的文件夹\\image-20200410183602021.png)\r\n\r\n* 静态web存在缺点\r\n  * web页面无法动态更新\r\n    * 轮播图,点击特效\r\n    * JavaScript[实际开发他用的最多]\r\n    * VBScript\r\n  * 他无法和数据库交互(数据无法持久)\r\n\r\n## 1.4 动态web\r\n\r\n页面动态展示:响应的web页面因人而异\r\n\r\n![image-20200410184013322](D:\\file\\Typora的文件夹\\image-20200410184013322.png)\r\n\r\n缺点:\r\n\r\n* 假如服务器的动态web资源出现错误,我们需要从新编写后台程序,从新发布;\r\n\r\n优点:\r\n\r\n* Web页面可以动态更新,所有用户看到的都不是同一个页面\r\n* 可以与数据库交互(数据持久化)\r\n\r\n![image-20200410184258266](D:\\file\\Typora的文件夹\\image-20200410184258266.png)\r\n\r\n# 2. web服务器\r\n\r\n## 2.1技术\r\n\r\nASP\r\n\r\n* 微软  国内最早流行的ASP\r\n* 在HTML中嵌入VB脚本,ASP+COM\r\n* 在ASP开发中,基本页面嵌入Java代码,能有几千行代码;\r\n* 维护成本高\r\n* C#\r\n* IIS\r\n\r\nPHP\r\n\r\n* PHP开发速度很快,功能强大,跨平台,代码简单\r\n* 无法承载打访问量的情况(局限性)\r\n\r\nJSP/Servlet\r\n\r\nB/S:浏览器和服务器\r\n\r\nC/S:客户端和服务器\r\n\r\n* sun公司主推的B/S架构\r\n* 基于Java语言的\r\n* 可承载三高(高并发,高可用,高性能)带来的影响\r\n* 语法像ASP,---------->加强市场强度;\r\n\r\n## 2.2 web服务器\r\n\r\n武器其实一种被动操作,用来处理用户的请求和给用户一些响应信息\r\n\r\nIIS\r\n\r\n微软的;ASP.....,在Windows中自带的\r\n\r\nTomcat;\r\n\r\n面向百度编程\r\n\r\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由[Apache](https://baike.baidu.com/item/Apache/6265)、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat ==技术先进、性能稳定，而且免费==，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\r\n\r\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于==轻量级应用服务器==，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的初学者来说，\r\n\r\nTomcat 实际上运行JSP 页面和Servlet。目前Tomcat最新版本为**10.0.0-M3。**\r\n\r\n**工作三到五年,可以尝试手写Tomcat服务器**\r\n\r\n下载Tomcat\r\n\r\n1.安装解压\r\n\r\n2.了解配置文件及目录结构\r\n\r\n3.这个东西的作用\r\n\r\n# 3. Tomcat\r\n\r\n## 3.1 前言\r\n\r\ntomcat官网:https://tomcat.apache.org/\r\n\r\n![image-20200410190503421](D:\\file\\Typora的文件夹\\image-20200410190503421.png)\r\n\r\n\r\n\r\n![image-20200410190519705](D:\\file\\Typora的文件夹\\image-20200410190519705.png)\r\n\r\n## 3.2 启动和配置\r\n\r\n### **1.文件夹作用**\r\n\r\n![image-20200410191459457](D:\\file\\Typora的文件夹\\image-20200410191459457.png)\r\n\r\n### **2.启动关闭,Tomcat**\r\n\r\n访问测试:https://localhost:8080/\r\n\r\n![image-20200410191650633](D:\\file\\Typora的文件夹\\image-20200410191650633.png)\r\n\r\n可能遇到的问题\"\r\n\r\n1. Java环境变量没有配置\r\n2. 闪退问题:需要配置兼容性\r\n3. 乱码问题:配置文件中设置\r\n\r\n### 3.配置\r\n\r\n![image-20200410192116393](D:\\file\\Typora的文件夹\\image-20200410192116393.png)\r\n\r\n**可以配置启动端口号**:默认:8080\r\n\r\nmysql:3306\r\n\r\nhttp:80\r\n\r\nhttps:443\r\n\r\n```xml\r\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"\r\n               connectionTimeout=\"20000\"\r\n               redirectPort=\"8443\" />\r\n```\r\n\r\n**可以配置主机的名称**:localhost---->127.0.0.1\r\n\r\n默认网站存放位置为 webapps\r\n\r\n```xml\r\n<Host name=\"localhost\"  appBase=\"webapps\"\r\n            unpackWARs=\"true\" autoDeploy=\"true\">\r\n\r\n```\r\n\r\n**面试题:**\r\n\r\n网站如何访问的?\r\n\r\n​		1.输入一个域名,回车\r\n\r\n​		2.检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件,是否有这个域名的映射\r\n\r\n* 有,直接返回对应的ip地址,本地有访问的web程序,可以访问\r\n* 无,到DNS服务器找,找不到,报丢失\r\n\r\n![image-20200410194807103](D:\\File\\Typora的文件夹\\image-20200410194807103.png)\r\n\r\n​			3.可以配置一下环境变量,(可选项)\r\n\r\n## 4.发布一个web网站\r\n\r\n不会就先模仿\r\n\r\n* 将自己写的网站放到服务器中(Tomcat等)指定的web应用文件夹(webapps)下就可以访问了\r\n* 网站应有的结果\r\n\r\n```java\r\n--webapps:Tomcat服务器的web目录\r\n	--Root\r\n	--kuangStufy :网站的目录名\r\n	--WEB-INF\r\n		-classes:Java程序\r\n		-lib:web应用所依赖的jar包\r\n		-web.xml:网站配置文件\r\n      -index.html 默认首页\r\n            -static\r\n             -css\r\n            	-style.css\r\n            -js\r\n            -img\r\n```\r\n\r\n# 4.Http\r\n\r\n## 4.1什么是http\r\n\r\n> http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。\r\n\r\nHTTP(超文本传输协议) http是一个简单的请求-响应协议，它通常运行在TCP之上.\r\n\r\n* 文本:tml,字符串-\r\n* 超文本:图片,音乐,视频,定位,地图\r\n* 端口 80\r\n\r\nHttps:安全的\r\n\r\n* 443\r\n\r\n## 4.2 两个时代\r\n\r\n* http1.0\r\n  * http/1.0 客户端可以与web服务器连接后.只能获得一个web资源(请求后断开连接)\r\n* http 2.0\r\n  * http/1.1: 客户端可以在与web服务器连接后,获得多个web资源\r\n\r\n## 4.3 http请求\r\n\r\n* 客户端---发请求(Request)---服务器\r\n\r\n百度\r\n\r\n````java\r\nRequest URL: https://www.baidu.com/   请求地址\r\nRequest Method: GET					get/post方法\r\nStatus Code: 200 OK					状态码:200\r\nRemote Address: 39.156.66.14:443	\r\nReferrer Policy: unsafe-url\r\n````\r\n\r\n```java\r\nAccept:text/html\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\r\nConnection: keep-alive\r\n```\r\n\r\n### 4.3.1.请求行\r\n\r\n* 请求行的请求方式:Get\r\n* 请求方式:Get;Post;HEAD;DELETE; PUT;TRACT....\r\n  * get:get方式能携带的参数较小,大小有限制,会在浏览器的URL地址栏显示数据内容,不安全,但高效\r\n  * post:post方法请求携带参数没有限制,大小没有限制,不会显示数据,安全,但不高效\r\n\r\n### 4.3.2.消息头\r\n\r\n```java\r\nAccept:告诉浏览器,支持的数据类型\r\nAccept-Encoding: 支持的编码格式 GBK UTF-8 GB2312 ISO8859-1\r\nAccept-Language: 告诉浏览器,语言环境\r\nCache-Control: 缓存控制\r\nConnection: 告诉浏览器,请求完成是断开还是保持连接\r\nHost: 主机..../\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 4.4 http响应\r\n\r\n服务器---响应(Response)----客户端\r\n\r\n百度:\r\n\r\n```java\r\nCache-Control: private					//缓存控制\r\nConnection: keep-alive					//连接:保持\r\nContent-Encoding: gzip					//编码\r\nContent-Type: text/html;charset=utf-8	//编码类型\r\n```\r\n\r\n### 1.响应体\r\n\r\n```java\r\nAccept:告诉浏览器,支持的数据类型;\r\nAccept-Encoding: 支持的编码格式 GBK UTF-8 GB2312 ISO8859-1;\r\nAccept-Language: 告诉浏览器,语言环境;\r\nCache-Control: 缓存控制;\r\nConnection: 告诉浏览器,请求完成是断开还是保持连接;\r\nHost: 主机..../;\r\nRefrush:告诉客户端多久刷新一次;\r\nLocation:网页重定位;\r\n```\r\n\r\n### 2.响应状态码\r\n\r\n200:请求响应成功\r\n\r\n3**:请求重定向\r\n\r\n* 重定向:请你到我给的新地址\r\n\r\n4***:找不到资源  404\r\n\r\n* 资源不存在\r\n\r\n5***: 服务器diamante错误 500  502 :网关错误\r\n\r\n**常见面试题:**\r\n\r\n当你的浏览器输入地址并回车的一瞬间,到页面能展示回来,经历了什么?\r\n\r\n# 5.Maven\r\n\r\n**为什么学习Maven?**\r\n\r\n1.在JavaWeb开发者,需要大量使用jar包,我们手动去导入;\r\n\r\n2.䄦让一个东西自动帮助我导入和配置这个jar包\r\n\r\n​			由此Maven诞生了\r\n\r\n## 5.1Maven项目价格管理工具\r\n\r\n我们目前用来方便导入jar包的!\r\n\r\nMaven核心思想**:==约定大于配置==**\r\n\r\n* 有约束,不要去违反\r\n\r\nMaven会规定好你如何去编写我们的Java代码,必须按照这个规范来;\r\n\r\n## 5.2 下载Maven\r\n\r\n官网:https://mvnrepository.com/\r\n\r\n完成后解压即可;\r\n\r\n建议:电脑上的所有环境放在一个目录下方便管理\r\n\r\n## 5.3 配置环境变量\r\n\r\n在我们的系统环境变量中配置如下配置\r\n\r\n* M2_HOME        : Maven目录下的bin目录\r\n* MAVEN_HOME :maven的目录\r\n* 在系统中的path中添加 %MAVEN_HOME%\\bin\r\n\r\n测试Maven是否安装成功,保证配置完毕\r\n\r\n## 5.4 阿里云镜像配置\r\n\r\nMaven国外网站,被墙,网速慢\r\n\r\n```xml\r\n <mirror>\r\n          <id>nexus-aliyun</id>\r\n          <mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf>\r\n          <name>Nexus aliyun</name>\r\n          <url>http://maven.aliyun.com/nexus/content/groups/public</url> \r\n      </mirror>\r\n```\r\n\r\n建立本地仓库\r\n\r\n```xml\r\n<!-- 配置本地仓库路径，默认在“D:\\Software\\Application Software\\apache-maven-workspace”路径下 -->\r\n	<localRepository>D:\\Software\\Application Software\\apache-maven-workspace</localRepository>\r\n```\r\n\r\n5.6 在IDEA中使用Maven\r\n\r\n1. 打开IDEA\r\n\r\n2. 创建Maven项目\r\n\r\n   ![image-20200410220544816](D:\\Document\\File\\Typora的文件夹\\image-20200410220544816.png)\r\n\r\n   ![image-20200410220844722](D:\\Document\\File\\Typora的文件夹\\image-20200410220844722.png)\r\n\r\n   3. 等待项目初始化完毕\r\n      注意:Maven可能会自动改为Maven默认MavenHome\r\n   4. 配置IDEAmaven设置\r\n\r\n![image-20200410221656517](D:\\Document\\File\\Typora的文件夹\\image-20200410221656517.png)\r\n\r\n## 5.5在idea中配置Tomcat\r\n\r\n![image-20200410222317902](D:\\Document\\File\\Typora的文件夹\\image-20200410222317902.png)\r\n\r\n**我们访问网站必须要有一个网站的目录文件夹,文件夹必须有名字**\r\n\r\n![image-20200410222349366](D:\\Document\\File\\Typora的文件夹\\image-20200410222349366.png)\r\n\r\n![image-20200410222535438](D:\\Document\\File\\Typora的文件夹\\image-20200410222535438.png)\r\n\r\n![image-20200410222629953](D:\\Document\\File\\Typora的文件夹\\image-20200410222629953.png)\r\n\r\n![image-20200410222718586](D:\\Document\\File\\Typora的文件夹\\image-20200410222718586.png)\r\n\r\n![image-20200410222923770](D:\\Document\\File\\Typora的文件夹\\image-20200410222923770.png)\r\n\r\n# 6. Servlet\r\n\r\n## 6.1 什么是Servlet?\r\n\r\n* Servlet就是sun公司开发动态web的一门技术;\r\n* sun公司在这些API中提供了一个接口叫做Servlet;如果你想开发一个Servlet程序,只需要完成两个步骤\r\n  * 编写类,实现Servlet接口\r\n  * 把开发好的java类部署到Web服务器中\r\n\r\n把实现了Servlet接口的Java程序较做,Servlet\r\n\r\n## 6.2 Hello Servlet\r\n\r\nServlet接口有两个默认实现类\r\n\r\n* HttpServlet\r\n* GenericServlet\r\n\r\n1. 构建一个Maven,删除src目录\r\n2. 关于Maven父子工程的理解\r\n\r\n父项目\r\n\r\n```xml\r\n<modules>\r\n    <module>javaweb-01-servlet</module>\r\n    <module>servlet-01</module>\r\n</modules>\r\n```\r\n\r\n子项目\r\n\r\n```xml\r\n<parent>\r\n    <artifactId>javaweb-study</artifactId>\r\n    <groupId>com.hu</groupId>\r\n    <version>1.0-SNAPSHOT</version>\r\n</parent>\r\n```\r\n\r\n子项目可以使用父项目的jar包;\r\n\r\n父项目不可以使用子项目jar包;\r\n\r\n\r\n\r\n3. Maven环境优化\r\n   * 修改web.xml为最新的\r\n   * 将Maven的结构建完整\r\n4. 编写一个servlet\r\n   1. 编写一个普通类\r\n   2. 实现Servlet接口:这里我们直接继承 HTTPServlet\r\n\r\n```java\r\npublic class HelloServlet extends HttpServlet {\r\n    //由于get和post只是请求实现的方式,可以相互调用,业务逻辑相同;\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        //req.getInputStream();\r\n\r\n        //ServletOutputStream outputStream = resp.getOutputStream();\r\n        PrintWriter writer = resp.getWriter();//响应流\r\n        writer.print(\"Hello,Servlet\");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        doGet(req,resp);\r\n    }\r\n}\r\n```\r\n\r\n5. 编写Servlet的映射\r\n\r\n   **为什么需要映射?**\r\n\r\n   * 我们写的java程序,但要通过浏览器访问,\r\n   * 而浏览器需要连接web服务器,\r\n   * 所以我们需要在**web服务**中**注册**我们写的**Servlet,**\r\n   * 还需要**给**他一个**浏览器**能**访问的路径**\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\r\n                               http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\r\n         version=\"4.0\"\r\n         metadata-complete=\"true\">\r\n    <!--注册Servlet-->\r\n    <servlet>\r\n        <servlet-name>hello</servlet-name>\r\n        <servlet-class>com.hu.servlet.HelloServlet</servlet-class>\r\n    </servlet>\r\n    <!--Servlet请求路径-->\r\n    <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello</url-pattern>\r\n    </servlet-mapping>\r\n</web-app>\r\n```\r\n\r\n6. 配置Tomcat\r\n   注意配置项目发布路径\r\n7. 启动测试\r\n\r\n## 6.3 Servlet原理\r\n\r\n![image-20200412110610449](image-20200412110610449.png)\r\n\r\n## 6.4 Mapping\r\n\r\n### 6.4.1 一个请求可以指定一个映射;\r\n\r\n```xml\r\n    <!--Servlet请求路径-->\r\n    <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello</url-pattern>\r\n    </servlet-mapping>\r\n```\r\n\r\n### 6.4.2.一个请求可以指定多个映射:\r\n\r\n```xml\r\n    <!--Servlet请求路径-->\r\n    <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello1</url-pattern>\r\n    </servlet-mapping>\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello2</url-pattern>\r\n    </servlet-mapping>\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello3</url-pattern>\r\n    </servlet-mapping>\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello4</url-pattern>\r\n    </servlet-mapping>\r\n```\r\n\r\n### 6.4.3.一个请求可以指定通配映射路径\r\n\r\n```xml\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello/*</url-pattern>\r\n    </servlet-mapping>\r\n```\r\n\r\n### 6.4.4.默认请求路径\r\n\r\n```xml\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </servlet-mapping>自定义后缀实现请求映射\r\n```\r\n\r\n### 6.4.5.自定义后缀完成映射\r\n\r\n```xml\r\n <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n     <!--*前面不能加映射路径\r\n		也不能加项目映射-->\r\n        <url-pattern>*.do</url-pattern>\r\n    </servlet-mapping>\r\n```\r\n\r\n### 6.4.6.优先级问题\r\n\r\n指定固有路径优先级最高.找不到就走默认的处理请求\r\n\r\n## 6.5 ServletContext\r\n\r\nweb容器在启动的时候,他会为每个web程序,创建一个ServletContext对象,他代表了当前web应用;\r\n\r\n### 1.共享数据\r\n\r\n我在这个servlet保存的数据可以和其他servlet共享\r\n\r\n* 输入数据到一个页面\r\n\r\n```java\r\npackage com.hu.servlet;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.io.PrintWriter;\r\n\r\npublic class HelloServlet extends HttpServlet {\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        doGet(req, resp);\r\n    }\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n\r\n        ServletContext servletContext = this.getServletContext();\r\n        String username =\"于谦\";\r\n        //将一个数据保存在了ServletContext,名字为:username,value为username\r\n        servletContext.setAttribute(\"username\",username);\r\n\r\n\r\n        //控制台输出\r\n        System.out.printf(\"Hello\");\r\n\r\n        //网页输出\r\n//        PrintWriter writer = resp.getWriter();\r\n//        writer.print(\"Hello,Servlet\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n获得上一个页面数据\r\n\r\n```java\r\npackage com.hu.servlet;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\npublic class ReadServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        ServletContext servletContext = this.getServletContext();\r\n        String username = (String) servletContext.getAttribute(\"username\");\r\n\r\n\r\n        resp.setContentType(\"text/html\");\r\n        resp.setCharacterEncoding(\"utf-8\");\r\n        resp.getWriter().print(\"名字是:\"+username);\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        doGet(req, resp);\r\n    }\r\n}\r\n\r\n```\r\n\r\n注册两个页面到服务器容器中:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\r\n                               http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\r\n         version=\"4.0\"\r\n         metadata-complete=\"true\">\r\n    <servlet>\r\n        <servlet-name>hello</servlet-name>\r\n        <servlet-class>com.hu.servlet.HelloServlet</servlet-class>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello</url-pattern>\r\n    </servlet-mapping>\r\n    <servlet>\r\n        <servlet-name>read</servlet-name>\r\n        <servlet-class>com.hu.servlet.ReadServlet</servlet-class>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>read</servlet-name>\r\n        <url-pattern>/read</url-pattern>\r\n    </servlet-mapping>\r\n</web-app>\r\n```\r\n\r\n* 测试访问结果\r\n\r\n### 2.获得初始化参数\r\n\r\n初始化参数:\r\n\r\n```xml\r\n    <context-param>\r\n        <param-name>url</param-name>\r\n        <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>\r\n    </context-param>\r\n```\r\n\r\n获取初始化参数\r\n\r\n```java\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n\r\n        ServletContext servletContext = this.getServletContext();\r\n        String url = servletContext.getInitParameter(\"url\");\r\n        resp.getWriter().print(url);\r\n    }\r\n```\r\n\r\n### 3.请求转发\r\n\r\n```java\r\n        @Override\r\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n\r\n            ServletContext servletContext = this.getServletContext();\r\n            RequestDispatcher requestDispatcher = servletContext.getRequestDispatcher(\"/gp\");\r\n            requestDispatcher.forward(req,resp);\r\n        }\r\n```\r\n\r\n**请求转发示意图**\r\n\r\n![image-20200412143014805](image-20200412143014805.png)\r\n\r\n**重定向示意图**\r\n\r\n![image-20200412143037708](image-20200412143037708.png)\r\n\r\n### 4.读取资源文件\r\n\r\nProperties\r\n\r\n* 在java文件夹下新建.properties文件\r\n* 在resources文件夹下新建.properties文件\r\n* 发现都到了target下的classes文件夹下,所以我们统称java+resources路径为classpath\r\n\r\n**读取资源文件:**\r\n\r\n* **思路,需要一个文件流**\r\n\r\n```properties\r\nusername=root\r\npassword=123456\r\n```\r\n\r\n**测试类:**\r\n\r\n注意maven资源可能导出不成功,可以配置pom.xml\r\n\r\n```xml\r\n<build>\r\n    <resources>\r\n        <resource>\r\n            <directory>src/main/resources</directory>\r\n            <includes>\r\n                <include>**/*.properties</include>\r\n                <include>**/*.xml</include>\r\n            </includes>\r\n            <filtering>false</filtering>\r\n        </resource>\r\n        <resource>\r\n            <directory>src/main/java</directory>\r\n            <includes>\r\n                <include>**/*.properties</include>\r\n                <include>**/*.xml</include>\r\n            </includes>\r\n            <filtering>false</filtering>\r\n        </resource>\r\n    </resources>\r\n</build>\r\n```\r\n\r\n**测试即可**\r\n\r\n## 6.6 HttpServletResponse\r\n\r\nweb服务器接收客户端的http请求,针对这个请求,分别创建一个代表请求的HttpServletRequest对象,和代表响应的一个HttpServletRequest\r\n\r\n* 如果要获取客户端请求过来的参数,找HttpServletRequest\r\n* 如果要给客户端响应一下信息,找HttpServletResponse\r\n\r\n### 1.简单分类\r\n\r\n负责向浏览器发送数据的方法\r\n\r\n```java\r\npublic ServletOutputStream getOutputStream() throws IOException;\r\npublic PrintWriter getWriter() throws IOException;\r\n<!--等等-->\r\n```\r\n\r\n负责向浏览器发送响应头的方法\r\n\r\n```java\r\npublic void setIntHeader(String name, int value);\r\npublic void addHeader(String name, String value);\r\npublic void setHeader(String name, String value);\r\n<!--等等-->\r\n```\r\n\r\n\r\n\r\n响应状态码常量\r\n\r\n```java\r\npublic static final int SC_CONTINUE = 100;\r\npublic static final int SC_SWITCHING_PROTOCOLS = 101;\r\npublic static final int SC_OK = 200;\r\npublic static final int SC_CREATED = 201;\r\npublic static final int SC_ACCEPTED = 202;\r\npublic static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;\r\npublic static final int SC_NO_CONTENT = 204;\r\npublic static final int SC_RESET_CONTENT = 205;\r\npublic static final int SC_PARTIAL_CONTENT = 206;\r\npublic static final int SC_MULTIPLE_CHOICES = 300;\r\npublic static final int SC_MOVED_PERMANENTLY = 301;\r\npublic static final int SC_MOVED_TEMPORARILY = 302;\r\npublic static final int SC_FOUND = 302;\r\npublic static final int SC_SEE_OTHER = 303;\r\npublic static final int SC_NOT_MODIFIED = 304;\r\npublic static final int SC_USE_PROXY = 305;\r\npublic static final int SC_TEMPORARY_REDIRECT = 307;\r\npublic static final int SC_BAD_REQUEST = 400;\r\npublic static final int SC_UNAUTHORIZED = 401;\r\npublic static final int SC_PAYMENT_REQUIRED = 402;\r\npublic static final int SC_FORBIDDEN = 403;\r\npublic static final int SC_NOT_FOUND = 404;\r\npublic static final int SC_METHOD_NOT_ALLOWED = 405;\r\npublic static final int SC_NOT_ACCEPTABLE = 406;\r\npublic static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;\r\npublic static final int SC_REQUEST_TIMEOUT = 408;\r\npublic static final int SC_CONFLICT = 409;\r\npublic static final int SC_GONE = 410;\r\npublic static final int SC_LENGTH_REQUIRED = 411;\r\npublic static final int SC_PRECONDITION_FAILED = 412;\r\npublic static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;\r\npublic static final int SC_REQUEST_URI_TOO_LONG = 414;\r\npublic static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;\r\npublic static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\r\npublic static final int SC_EXPECTATION_FAILED = 417;\r\npublic static final int SC_INTERNAL_SERVER_ERROR = 500;\r\npublic static final int SC_NOT_IMPLEMENTED = 501;\r\npublic static final int SC_BAD_GATEWAY = 502;\r\npublic static final int SC_SERVICE_UNAVAILABLE = 503;\r\npublic static final int SC_GATEWAY_TIMEOUT = 504;\r\npublic static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\r\n```\r\n\r\n### 2. 常见应用\r\n\r\n1. 向浏览器输出消息\r\n\r\n2. 下载文件\r\n   1.下载文件的路径获取\r\n   2.下载文件名是什么?\r\n   3.设置想办法让浏览器能够支持下载\r\n   4.获取下载文化的输入流\r\n   5.创建缓存区\r\n   6.获取OutputStream对象\r\n   7.将FileOutputStream流写入到缓存区\r\n   8.使用OutputStream将缓冲区中的数据输出到客户端\r\n\r\n   ```java\r\n   package com.hu.servlet;\r\n   \r\n   import javax.servlet.ServletException;\r\n   import javax.servlet.ServletOutputStream;\r\n   import javax.servlet.http.HttpServlet;\r\n   import javax.servlet.http.HttpServletRequest;\r\n   import javax.servlet.http.HttpServletResponse;\r\n   import java.io.FileInputStream;\r\n   import java.io.IOException;\r\n   import java.net.URLEncoder;\r\n   \r\n   \r\n   public class FileServlet extends HttpServlet {\r\n       @Override\r\n       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n           /*下载文件功能设计思路*/\r\n           //1.下载文件的路径获取\r\n           String realPath =\"D:\\\\file\\\\core\\\\idea_core\\\\response\\\\target\\\\classes\\\\于谦.png\";\r\n           System.out.println(\"要下载的路径是:\" + realPath);\r\n           //2.下载文件名是什么?\r\n           /*截取最后一个\"/\"的后面的_记得转义_*/\r\n           String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1);\r\n           //3.设置想办法让浏览器能够支持下载，URLEncoder.encode(fileName,\"UTF-8\")转码名字为UTF-8，否则有可能乱码\r\n           resp.setHeader(\"Content-Disposition\", \"attachment;filename=\"+URLEncoder.encode(fileName,\"UTF-8\"));\r\n           //4.获取下载文化的输入流\r\n           FileInputStream in = new FileInputStream(realPath);\r\n           //5.创建缓存区\r\n           int len = 0;\r\n           byte[] buffer = new byte[1024];\r\n           //6.获取OutputStream对象\r\n           ServletOutputStream out = resp.getOutputStream();\r\n           /* 7.将FileOutputStream流写入到缓存区\r\n            * 8.使用OutputStream将缓冲区中的数据输出到客户端\r\n            */\r\n           while ((len = in.read(buffer)) !=-1) {\r\n               out.write(buffer, 0, len);\r\n           }\r\n           in.close();\r\n           out.close();\r\n       }\r\n   \r\n       @Override\r\n       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n           doGet(req, resp);\r\n       }\r\n   }\r\n   ```\r\n\r\n### 3. 验证码功能\r\n\r\n1. 前端实现\r\n2. 后端实现:java实现----项目:javaweb/response\r\n\r\n```java\r\npackage com.hu.servlet;\r\nimport javax.imageio.ImageIO;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.util.Random;\r\npublic class ImageServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        //浏览器3s刷新一次\r\n        resp.setHeader(\"refresh\",\"3\");\r\n        //内存中创建一个空白图片\r\n        BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB);\r\n        //画出图片\r\n        Graphics2D g =(Graphics2D) image.getGraphics();\r\n        //设置图片的背景色\r\n        g.setColor(Color.white);\r\n        g.fillRect(0,0,80,20);\r\n        //给图片写数据\r\n        g.setColor(Color.blue);\r\n        g.setFont(new Font(null,Font.BOLD,20));\r\n        g.drawString(makeNum(),0,20);\r\n        //告诉浏览器这个请求用图片的形式打开\r\n        resp.setContentType(\"image/jpg\");\r\n        //网站存在缓存，不让浏览器缓存\r\n        resp.setDateHeader(\"expires\",-1);\r\n        resp.setHeader(\"Cache-Control\",\"no-cache\");\r\n        resp.setHeader(\"pragma\",\"no-cache\");\r\n        //把图片给浏览器\r\n        ImageIO.write(image,\"jpg\",resp.getOutputStream());\r\n    }\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        doGet(req, resp);\r\n    }\r\n    //生产随机数\r\n    private String makeNum(){\r\n        Random random =new Random();\r\n        String num=random.nextInt(9999999)+\"\";\r\n        StringBuffer sb =new StringBuffer();\r\n        for (int i=0;i<7-num.length();i++){\r\n            sb.append(\"0\");\r\n        }\r\n        num=sb.toString()+num;\r\n        return num;\r\n    }\r\n}\r\n```\r\n\r\n### 4. 重定向\r\n\r\nB一个web资源收到客户端A请求后,B会通知A取访问C的web资源,这个过程叫做重定向;\r\n\r\n常见场景:用户登录.\r\n\r\n```java\r\npublic void sendRedirect(String location) throws IOException;\r\n```\r\n\r\n测试:\r\n\r\n```java\r\n   @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        //重定向分解步骤:  1.在头部设置头部转移到的地址     2.给出状态码\r\n        //resp.setHeader(\"location\",\"/response_war/img\");\r\n        //resp.setStatus(302);\r\n\r\n        resp.sendRedirect(\"/response_war/img\");\r\n    }\r\n```\r\n\r\n#### 笔试:\r\n\r\n重定向与转发的区别:\r\n\r\n* 相同点:\r\n  * 页面都会跳转\r\n* 不同点:\r\n  * 请求转发,url不会发生变化\r\n  * 重定向,url发送变化\r\n\r\n\r\n\r\n## 6.7 HttpServletRequest\r\n\r\nHttpServletRequest代表客户端的请求;用户通过Http访问服务器,http请求的所有信息会被封装到context,\r\n通过request方法我们可以获得客户端发出的所有信息.\r\n\r\n1.获取前端传递的参数,请求转发.\r\n\r\n![image-20200413114407871](image-20200413114407871.png)\r\n\r\n```java\r\n@Override\r\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n    //解决乱码\r\n    req.setCharacterEncoding(\"UTF-8\");\r\n    resp.setCharacterEncoding(\"utf-8\");\r\n\r\n    String username = req.getParameter(\"username\");\r\n    String password = req.getParameter(\"password\");\r\n    String[] hobbys = req.getParameterValues(\"hobbys\");\r\n    System.out.println(\"====================\");\r\n    System.out.println(username);\r\n    System.out.println(password);\r\n    System.out.println(Arrays.toString(hobbys));\r\n    System.out.println(\"====================\");\r\n    //通过请求转发\r\n    //注意这里的\"/\"代表当前web应用\r\n    req.getRequestDispatcher(\"/success.jsp\").forward(req,resp);\r\n}\r\n```\r\n\r\n**重定向与转发的区别:**\r\n\r\n* **相同点:**\r\n  * **页面都会跳转**\r\n* **不同点:**\r\n  * **请求转发,url不会发生变化** 307\r\n  * **重定向,url发送变化** 302\r\n\r\nSession\r\n\r\nCookie\r\n\r\nJSP:--->HTML+JS\r\n\r\n2.\r\n###未完待续。。。。。', '2020-06-11 05:19:56', 'javaweb学习，（未完成）', 'https://images.unsplash.com/photo-1591612523880-5c0790890bc7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'JavaWeb学习', '2020-03-29 16:29:56', 0, 59, 1, 0);
INSERT INTO `t_blog` VALUES (69, b'1', b'1', '# \r\n\r\nMybatis模块详析\r\n\r\n## 一.main\r\n\r\n### 1.Java\r\n\r\n#### (1)dao层----实现类\r\n\r\n* Mapper接口							**(eq:UserMapper接口)**\r\n  * 封装了Mapper对象的所有SQL操作的抽象方法\r\n* Mapper.xml配置文件             **(eq:UserMapper.xml)**\r\n  * 对Mapper中所有**SQL抽象方法的具体实现**\r\n  * 与Mapper对象绑定\r\n  * 需要在核心配置文件(mybatis-config.xml)中说明\r\n\r\n#### (2)pojo层-----实体类\r\n\r\n* Mapper接口的具体实体类            **(eq:User类)**\r\n\r\n#### (3)utils层-----工具类\r\n\r\n* MyBatisUtils工具类                       **(eq:MyBatisUtils)**\r\n\r\n### 2 Resources\r\n\r\n#### (1)外部配置文件\r\n\r\n* ***.properties文件**\r\n  * 需要在核心配置文件中引入\r\n  * 当外部配置文件与内部配置冲突时,<u>**优先执行外部文件**</u>\r\n\r\n#### (2)核心配置文件\r\n\r\n* ***<u>MyBatis-config.xml</u>***\r\n  * 决定了MyBatis的环境,设置等一切核心问题\r\n\r\n## 二.test\r\n\r\n### 测试工具的存放位置\r\n\r\n\r\n\r\n## 三. Mybatis运行过程\r\n\r\n![image-20200405144306253](D:\\File\\Typora的文件夹\\image-20200405144306253.png)\r\n\r\n## 四.dao层与service层详悉\r\n\r\n### userdao：\r\n\r\npublic interface UserDao {\r\n\r\n```java\r\npublic List<User> findAll();\r\n\r\npublic User findById(String id);\r\n\r\npublic void update(User user);\r\n\r\npublic void add(User user);\r\n\r\npublic void delete(String id);\r\n\r\npublic User findByIdAndPassword(@Param(\"id\") String username, @Param(\"password\") String password);\r\n\r\npublic void updatePassword(@Param(\"userId\") String id, @Param(\"password\") String password);\r\n\r\nUser findByUsername(String username);}\r\n```\r\n\r\n在接口中对方法进行了定义，在UserDao.xml中给出了sql语句实现\r\n在UserDao中，就对user这个实体的增删补查各类基本的操作进行了声明，并用mybatis框架进行实现。\r\n\r\n下面给出部分UserDao.xml的代码\r\n\r\n\r\n```xml\r\n<select id=\"findAll\" resultMap=\"user_map\">\r\n    SELECT * FROM user WHERE user_id != \'admin\'\r\n</select>\r\n<select id=\"findById\" parameterType=\"String\" resultMap=\"user_map\">\r\n    SELECT * FROM user WHERE user_id = #{value}\r\n</select>\r\n\r\n<update id=\"update\" parameterType=\"User\">\r\n    UPDATE user SET password = #{password} ,authority = #{authority} WHERE user_id = #{userId}\r\n</update>\r\n\r\n<update id=\"updatePassword\" parameterType=\"map\">\r\n    UPDATE user SET password = #{password} WHERE user_id = #{userId}\r\n</update>\r\n\r\n<insert id=\"add\" parameterType=\"User\">\r\n    INSERT INTO user(user_id,password,salt,role_ids,locked) VALUES(#{userId},#{password},#{salt},#{roleIdsStr},#{locked})\r\n</insert>\r\n\r\n<select id=\"findByIdAndPassword\" parameterType=\"map\" resultMap=\"user_map\">\r\n    SELECT * FROM user WHERE user_id = #{id} AND password = #{password}\r\n</select>\r\n```\r\n\r\n### service层\r\n\r\n下面来看看service层的代码\r\n\r\n```java\r\nimport com.giit.www.entity.User;\r\nimport com.giit.www.entity.custom.UserVo;\r\n\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n/**\r\n\r\n * Created by c0de8ug on 16-2-9.\r\n   */\r\n   public interface UserBiz {\r\n   public List<UserVo> findAll() throws InvocationTargetException, IllegalAccessException;\r\n\r\n   public User findById(String id);\r\n\r\n   public void update(User user);\r\n\r\n   public void add(User user);\r\n\r\n   public void delete(String id);\r\n\r\n   public void changePassword(String userId, String newPassword);\r\n```\r\n\r\n\r\n\r\n\r\n```java\r\npublic User findByUsername(String username);\r\n\r\npublic Set<String> findRoles(String username);\r\n\r\npublic Set<String> findPermissions(String username);\r\n```\r\n\r\n显然，service层里面的方法相较于dao层中的方法进行了一层包装，例如通过id查找用户，通过用户名查找用户，是在基础的操作上又增加了一层包装的，实现的是相对高级的操作。最后将这些操作在serviceimpl类中实现，代码比较多，这里还是只给出了部分代码，\r\n\r\n\r\n\r\n```java\r\nimport com.giit.www.college.dao.StaffDao;\r\nimport com.giit.www.entity.Role;\r\nimport com.giit.www.entity.Staff;\r\nimport com.giit.www.entity.User;\r\nimport com.giit.www.entity.custom.UserVo;\r\nimport com.giit.www.system.dao.RoleDao;\r\nimport com.giit.www.system.dao.UserDao;\r\nimport com.giit.www.system.service.RoleBiz;\r\nimport com.giit.www.system.service.UserBiz;\r\nimport com.giit.www.util.PasswordHelper;\r\nimport org.apache.commons.beanutils.BeanUtils;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport javax.annotation.Resource;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.*;\r\n\r\n/**\r\n\r\n * Created by c0de8ug on 16-2-9.\r\n   */\r\n\r\n@Service\r\npublic class UserBizImpl implements UserBiz {\r\n@Resource\r\nUserDao userDao;\r\n@Resource\r\nRoleDao roleDao;\r\n\r\n@Resource\r\nStaffDao staffDao;\r\n\r\n@Resource\r\nprivate PasswordHelper passwordHelper;\r\n@Resource(name = \"roleBizImpl\")\r\nprivate RoleBiz roleBiz;\r\n\r\n@Override\r\npublic List<UserVo> findAll() throws InvocationTargetException, IllegalAccessException {\r\n    List<UserVo> userVoList = new ArrayList<>();\r\n    List userList = userDao.findAll();\r\n      Iterator iterator = userList.iterator();\r\n\r\n    while (iterator.hasNext()) {\r\n        StringBuilder s = new StringBuilder();\r\n        User user = (User) iterator.next();\r\n        List<Long> roleIds = user.getRoleIds();\r\n\r\n        UserVo userVo = new UserVo();\r\n        BeanUtils.copyProperties(userVo, user);\r\n\r\n        if (roleIds != null) {\r\n            int i = 0;\r\n            int size = roleIds.size();\r\n            for (; i < size - 1; i++) {\r\n                Role role = roleDao.findOne(roleIds.get(i));\r\n\r\n                s.append(role.getDescription());\r\n                s.append(\",\");\r\n            }\r\n            Role role = roleDao.findOne(roleIds.get(i));\r\n            s.append(role.getDescription());\r\n            userVo.setRoleIdsStr(s.toString());\r\n        }\r\n                userVoList.add(userVo);\r\n\r\n    }\r\n\r\n    return userVoList;\r\n}\r\n由此看到，这样进行分层，访问数据库和进行service之间的分工明确，如果我需要对service的需求修改，无需改变dao层的代码，只要在实现上改变即可，如果我有访问数据库的新需求，那我也只要在dao层的代码中增添即可。\r\n```\r\n\r\n> service是业务层\r\n> DAO (Data Access Object) 数据访问\r\n>\r\n> 1.JAVA中Action层, Service层 ，modle层 和 Dao层的功能区分？（下面所描述的service层就是biz）\r\n>      首先这是现在最基本的分层方式，结合了SSH架构。modle层就是对应的数据库表的实体类。\r\n> Dao层是使用了Hibernate连接数据库、操作数据库（增删改查）。\r\n> 以上的Hibernate，Struts，都需要注入到Spring的配置文件中，Spring把这些联系起来，成为一个整体\r\n> 其他答案：\r\n> action 是业务层的一部分，是一个管理器 （总开关）（作用是取掉转）（取出前台界面的数据，调用biz方法，转发到下一个action或者页面）模型成（model）一般是实体对象(把现实的的事物变成java中的对象)作用是一暂时存储数据方便持久化（存入数据库或者写入文件）而是 作为一个包裹封装一些数据来在不同的层以及各种java对象中使用   dao是数据访问层  就是用来访问数据库实现数据的持久化（把内存中的数据永久保存到硬盘中）\r\n>\r\n> 其他答案：\r\n> Action是一个控制器 Dao主要做数据库的交互工作 Modle 是模型存放你的实体类 Biz 做相应的业务逻辑处理  \r\n>\r\n> 2.java中dao层和biz层的区别是什么？（自己百度的结果，不代表本人观点）\r\n>      刚学编程的时候，都是在service里直接调用dao，service里面就new一个dao类对象，调用，其他有意义的事没做，也不明白有这个有什么用，参加工作久了以后就会知道，业务才是工作中的重中之重。\r\n> 我们都知道，标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦，解耦说的意思是你更改某一层代码，不会影响我其他层代码，如果你会像spring这样的框架，你会了解面向接口编程，表示层调用控制层，控制层调用业务层，业务层调用数据访问层。初期也许都是new对象去调用下一层，比如你在业务层new一个DAO类的对象，调用DAO类方法访问数据库，这样写是不对的因为在业务层中是不应该含有具体对象，最多只能有引用，如果有具体对象存在，就耦合了。当那个对象不存在，我还要修改业务的代码，这不符合逻辑。好比主板上内存坏了，我换内存，没必要连主板一起换。我不用知道内存是哪家生产，不用知道多大容量只要是内存都可以插上这个接口使用。这就是MVC的意义。 接下来说你感觉service的意义，其实因为你现在做东西分层次不是那么严格，在一个你们做东西业务本身也少，举个最简单的例子，你做一个分页的功能，数据1000条，你20条在一个页，你可以把这个功能写成工具类封装起来，然后在业务层里调用这个封装的方法，这才是业务里真正干得事，只要没访问数据库的，都要在业务里写。\r\n>      再有不明白的追问，这是经验问题，呵呵，其实以后你就会懂。只是刚开始写的代码都是有个请求，我就去数据库取，业务几乎没有。  \r\n>\r\n> 其他优秀答案：\r\n> (1)、假设现在你做这个功能会用到user表和权限表，那么你前台的页面访问action，action再去调用用户模块service，用户模块service判断你是操作user表还是权限表，如果你操作的是user表则service的实现类就去调用userDAO。如果是操作的是权限表则调用权限的DAO   \r\n> (2)、也就是说DAO一定是和数据库的每张表一一对应，而service则不是。明白的没？其实你一个项目个service和一个DAO其实也一样可以操作数据库，只不过那要是表非常多，出问题了，那找起来多麻烦，而且太乱了 。\r\n> (3)、好处就是你的整个项目非常系统化，和数据库的表能一致，而且功能模块化，这样以后维护或者改错比较容易，性能也高一些  至于你说的为什么要用service层封装，我认为：一般来说，某一个程序的有些业务流程需要连接数据库，有些不需要与数据库打交道而直接是一些业务处理，这样就需要我们整合起来到service中去，这样可以起到一个更好的开发与维护的作用，同时也是MVC设计模式中model层功能的体现  \r\n>\r\n> 3.java中的action是什么，DAO又是什么？\r\n> Action类 是 [ 获得Form表单数据，并处理逻辑的类 ]  \r\n>      DAO(Data Access Object) 是一个接口实现 [ 通过SessionFactory获得操作数据库的会话，并实现一些基本的删除 添加 修改数据，在servlet中更实际化业务操作 ]\r\n>\r\n> 4. 什么是Pojo类？\r\n>    简单的Java对象（Plain Old Java Objects）实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。  \r\n>\r\n> 5.pojo类和vo类分别是什么\r\n> vo有两种说法,一个是viewObject,一个是valueObject..\r\n>         就拿前者来说吧,它只负责封装页面传递过来的数据,这和PO有些不同..\r\n>         就拿struts1来说,ActionForm就是一个典型的viewObject. 而valueObject是页面与页面之间的传递时保存值的对象....\r\n>         总的来说,PO是最终传给BO以及BO传个DAO的东西,他很多情况下与我们真正的数据库表想对应.\r\n>         而viewObject是一个页面上提交后的数据,不一定完全和PO的属性相同.... \r\n\r\n> pojo就是不依赖任何框架的纯java类，例如如果一个类实现了某个框架的某个接口，那么这个类就是框架相关的类了，就不是pojo。\r\n>\r\n> dao是data access object，即数据访问对象。数据可能保存到各种数据库，或者各种文件，或者内存。dao层隐藏了这种实现细节，更换数据库或者文件或者内存，对调用dao的更高层来说不受影响。\r\n>\r\n> mapper和dao不同，mapper的目的是为了把关系数据库映射成java类（对象）。因此，如果只有mapper没有dao层，那么一旦项目需要把数据保存到文件或者内存，那么调用mapper的高层就会受到影响。\r\n>\r\n> \\---------\r\n>\r\n> 一般的项目可能只会使用数据库作为数据存储，所以mapper和dao可以说上就是一个东西了。', '2020-06-11 05:21:32', 'mybatis各个模块的了解与分析。', 'https://images.unsplash.com/photo-1591639903473-2d7250af207d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'Mybatis模块详解', '2020-05-01 05:21:32', 0, 61, 1, 0);
INSERT INTO `t_blog` VALUES (70, b'1', b'1', '# **1.spring**\r\n\r\n## 1.1简介\r\n\r\nSpring框架是由于软件开发的复杂性而创建的。\r\n\r\nSpring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。\r\n\r\n◆目的：解决企业应用开发的复杂性\r\n\r\n◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能\r\n\r\n◆范围：任何Java应用\r\n\r\nSpring是一个**轻量级**==控制反转(IoC)和面向切面(AOP)==的容器框架。\r\n\r\nSpring的理念:使得现有技术更容易应用,本身是个大杂烩,整合了现有的技术框架\r\n\r\n* SSH Struct +Spring+Hibernate\r\n* SSM SpringMvc+Spring+Mybatis\r\n\r\nSpring官网地址:https://spring.io/projects/spring-framework\r\n\r\nSpringGitHub:https://github.com/spring-projects/spring-framework\r\n\r\nSpring官方下载地址:https://repo.spring.io/release/org/springframework/spring/\r\n\r\nMaven导入:\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>5.2.5.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-jdbc</artifactId>\r\n    <version>5.2.5.RELEASE</version>\r\n</dependency>\r\n\r\n```\r\n\r\n## 1.2 优点\r\n\r\n* Spring是一个开源的免费框架\r\n* Spring是一个轻量级,非入侵式的框架\r\n* 控制翻转(IoC),面向切面编程(AOP)\r\n* 支持事务的出力,对框架的整合\r\n\r\n### ==总结==\r\n\r\nSpring是一个轻量级的控制翻转(IoC)的,面向切面编程的框架\r\n\r\n## 1.3 组成\r\n\r\n![](D:\\Document\\File\\Typora的文件夹\\Spring的七大模块.gif)\r\n\r\n> **核心容器（Spring Core）**\r\n>\r\n> 　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。\r\n>\r\n> **应用上下文（Spring Context）**\r\n>\r\n> 　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。\r\n>\r\n> **Spring面向切面编程（Spring AOP）**\r\n>\r\n> 　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\r\n>\r\n> **JDBC和DAO模块（Spring DAO）**\r\n>\r\n> 　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。\r\n>\r\n> **对象实体映射（Spring ORM）**\r\n>\r\n> 　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。\r\n>\r\n> **Web模块（Spring Web）**\r\n>\r\n> 　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\r\n>\r\n> **MVC模块（Spring Web MVC）**\r\n>\r\n> 　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。\r\n\r\n## 1.4 拓展\r\n\r\n在spring的官网介绍,现代的开发:Spring的开发\r\n\r\n![image-20200407104230509](D:\\Document\\File\\Typora的文件夹\\image-20200407104230509.png)\r\n\r\n* Spring Boot\r\n  * 一个快速开发的脚手架\r\n  * 基于SpringBoot可以快速的开发单个微服务\r\n  * 约定大于配置\r\n* Spring Cloud\r\n  * SpringCloud 是居于SprinBoot进行快速开发\r\n\r\n因为现在大多数公司使用SpringBoot进行快速开发,学习SpringBoot的前提是掌握Spring和SpringMVC,所以他们有承上启下的作用\r\n\r\n弊端:发展了太久,违背了原来的理念!**配置的地狱**\r\n\r\n# 2. IoC理论推导\r\n\r\n1. UserDao接口 \r\n\r\n   \r\n\r\n2. UersDaoImpl实现类\r\n\r\n   \r\n\r\n3. UserService业务接口\r\n\r\n   \r\n\r\n4. UserServiceImpl业务实现类\r\n\r\n\r\n\r\n## **==1.IoC的原型==**\r\n\r\n我们使用一个Set接口实现,已经发生了革命性的变化\r\n\r\n```java\r\n/**\r\n * Service层是面向程序猿的,对用户透明\r\n */\r\n    public void getUser() {\r\n        userDao.getUser();\r\n    }\r\n    /**\r\n     * 利用Set方法动态实现值的注入\r\n     * userDao的类型转到MyTest选择,不再需要程序主动为用户配置\r\n     */\r\n    private UserDao userDao;\r\n    //利用set进行动态实现值的注入,不在service层确定userDao的类型\r\n    public void setUserDao(UserDao userDao) {\r\n        this.userDao = userDao;\r\n    }\r\n}\r\n\r\n```\r\n\r\n* 之前是程序触动创建对象,控制权在程序猿手上;\r\n* 使用了set注入后,程序不再有主动性,而是变成了被动接受对象.\r\n\r\n![image-20200408120427817](D:\\Document\\File\\Typora的文件夹\\image-20200408120427817.png)\r\n\r\n**这种思想从本质上解决了问题,程序不再管理创建对象,系统 的耦合性大大降低,系统只需要关注业务实现**\r\n\r\n## 2.业务逻辑\r\n\r\n> 业务逻辑：\r\n>\r\n> ​    Controller-->service接口-->serviceImpl-->dao接口-->daoImpl-->mapper-->db\r\n>\r\n> 一：Dao(Data Access Object):数据存储对象\r\n>\r\n> 不管是什么框架，我们很多时候都会与数据库进行交互。如果遇到一个场景我们都要去写SQL语句，那么我们的代码就会很冗余。所以，我们就想到了把数据库封装一下，让我们的数据库的交道看起来像和一个对象打交道，这个对象通常就是DAO。当我们操作这个对象的时候，这个对象会自动产生SQL语句来和数据库进行交互，我们就只需要使用DAO就行了。\r\n>\r\n> 通常我们在DAO层里面写接口，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的。\r\n>\r\n> 二：Service：服务\r\n>\r\n> 服务是一个相对独立的功能模块，主要负责业务逻辑应用设计。首先也要设计接口，然后再设计其实现该接口的类。这样我们就可以在应用中调用service接口进行业务处理。service层业务实现，具体调用到已经定义的DAO的接口，封装service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性 。\r\n>\r\n> 三：Controller：控制器\r\n>\r\n> 主要负责具体业务模块流程的控制，会调用Service层的接口来控制业务逻辑 \r\n>\r\n> 四：model：模型\r\n>\r\n> ​    模型通常认为是视图(view)的内核，模型就是指视图的数据\r\n>\r\n> 简而言之：\r\n>\r\n> Service 写api 的，Controller写逻辑的 业务，model：就是对象模型，Dao 跟 mapper 一样的 处理数据的。\r\n>\r\n> \r\n>\r\n> 作者：说不出口的秒\r\n> 链接：https://www.jianshu.com/p/3e6710989bf3\r\n> 来源：简书\r\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n## ==3.IoC的本质==\r\n\r\n![image-20200408120749917](D:\\Document\\File\\Typora的文件夹\\image-20200408120749917.png)\r\n\r\n\r\n\r\n### **1.IoC是Spring的核心**\r\n\r\n![image-20200408120956200](D:\\Document\\File\\Typora的文件夹\\image-20200408120956200.png)\r\n\r\n### 2.IoC**的实现方式**\r\n\r\n![image-20200408121800142](D:\\Document\\File\\Typora的文件夹\\image-20200408121800142.png)\r\n\r\n\r\n\r\n### 3.总结\r\n\r\n**这个过程就是IoC(控制反转):**\r\n\r\n![image-20200408204756606](D:\\Document\\File\\Typora的文件夹\\image-20200408204756606.png)\r\n\r\n如此我们彻底不需要因为用户需求变更取修改程序的源代码了,只需要在原有基础上添加新的实现方式,去完成不同的操作,而这只需要在xml配置文件中修改,\r\n\r\n**==IoC就是:对象由Spring来创建,管理,装配(注入);==**\r\n\r\n\r\n\r\n# 3.学习第一个Spring程序HelloSpring\r\n\r\n## 1.建立Hello实体类\r\n\r\n```java\r\npackage com.hu.pojo;\r\n\r\npublic class Hello {\r\n    private String str;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Hello{\" +\r\n                \"str=\'\" + str + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n\r\n    public String getStr() {\r\n        return str;\r\n    }\r\n\r\n    public void setStr(String str) {\r\n        this.str = str;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 2. 把Hello类装入Spring容器\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!--使用Spring创建对象,在Spring中,这些都被称为bean\r\n    类型 变量名 = new 类型();\r\n    bean=对象  new Hello\r\n    id == 变量名  class== new的对象\r\n    property ==给对象中的属性设置一个值-->\r\n    <bean id=\"hello\" class=\"com.hu.pojo.Hello\">\r\n        <property name=\"str\" value=\"Spring\"/>\r\n    </bean>\r\n    <!--以下托管不同的实现方法-->\r\n\r\n</beans>\r\n```\r\n\r\n## 3. 测试Hello\r\n\r\n```java\r\nimport com.hu.pojo.Hello;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class MyTest {\r\n    public static void main(String[] args) {\r\n        //获取Spring的上下文对象,调入Spring容器,并实例化beans.xml下所有已经注册的类\r\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\r\n        //我们的对象现在都在Spring中管理,要使用直接从Spring中取出\r\n        Hello hello = (Hello) context.getBean(\"hello\");\r\n        System.out.println(hello.toString());\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 4.思考\r\n\r\n* Hello的对象hello是谁创建的?\r\n\r\n  * hello是由Spring创建的.\r\n\r\n* Hello的对象hello是怎么创建的?\r\n\r\n  * 由配置文件注入数据通过Spring容器创建的\r\n\r\n* Hello的对象属性是怎么创建的?\r\n\r\n  * hello对象的属性是由Spring容器设置的\r\n\r\n  * ```xml\r\n    <!--使用Spring创建对象,在Spring中,这些都被称为bean\r\n      类型 变量名 = new 类型();\r\n      bean==对象  new Hello\r\n      id == 变量名  class== new的对象\r\n      property ==给对象中的属性设置一个值-->\r\n      <bean id=\"hello\" class=\"com.hu.pojo.Hello\">\r\n          <property name=\"str\" value=\"Spring\"/>\r\n      </bean>\r\n      <!--以下托管不同的实现方法-->\r\n    ```\r\n\r\n# 4.IoC创建对象的方式\r\n\r\n1. 默认使用无参构造方法\r\n\r\n2. 有参构造方法创建对象\r\n\r\n   1. 下标赋值\r\n\r\n      * 下标代表构造函数的参数数量,从0开始\r\n\r\n      ```xml\r\n        <bean id=\"user\" class=\"com.hu.pojo.User\">\r\n              <constructor-arg index=\"0\" value=\"夕阳\"/>\r\n          </bean>\r\n      ```\r\n\r\n      \r\n\r\n   2. 构造函数参数类型匹配\r\n\r\n      ```xml\r\n         <!--不建议使用\r\n          构造函数参数类型匹配-->\r\n          <bean id=\"user\" class=\"com.hu.pojo.User\">\r\n              <constructor-arg type=\"java.lang.String\" value=\"类型\"></constructor-arg>\r\n          </bean>\r\n      ```\r\n\r\n      \r\n\r\n   3. 构造函数参数名赋值\r\n\r\n      ```xml\r\n        <!--参数的名称赋值-->\r\n          <bean id=\"user\" class=\"com.hu.pojo.User\">\r\n              <constructor-arg name=\"name\" value=\"参数名称赋值\"></constructor-arg>\r\n          </bean>\r\n      ```\r\n\r\n\r\n\r\n**在配置文件加载的时候,容器中的对象就已经实例化了!**\r\n\r\n# 5. Spring配置\r\n\r\n## 5.1 别名\r\n\r\n```xml\r\n   <!--如果添加了别名,我们也可以通过别名获取到这个对象-->\r\n    <alias name=\"user\" alias=\"asdad\"/>\r\n```\r\n\r\n\r\n\r\n## 5.2Bean的配置\r\n\r\n```xml\r\n<!-- \r\nid:bean的唯一标识符,相当于对象名\r\nclass:bean对象所对应的全限定类名\r\nname:也是别名,而且name更高级,可以取多个name,中间用空格,逗号,分号等都可以分割\r\n-->\r\n<bean id=\"userT\" class=\"com.hu.pojo.UserT\" name=\"user2 u2,U2;utwo\"></bean>\r\n```\r\n\r\n\r\n\r\n## 5.3 import\r\n\r\nimport,一般用户团队开发,可以把多个配置文件并存为一个配置文件\r\n\r\n假设现在有多个程序猿,这三人负责开发不同的类,那么不同的类注册在各自beans.xml中,我们可以通过import将所有人的beans.xml合成为一个总的.\r\n\r\n* 张三\r\n* 李四\r\n* 王五\r\n* applicationContext.xml\r\n\r\n```xml\r\n<import resource=\"zhangsan_beans.xml\"/>\r\n<import resource=\"lisi_beans.xml\"/>\r\n<import resource=\"wangwu_beans.xml\"/>\r\n```\r\n\r\n使用的时候使用总配置文件就可以了\r\n\r\n# 6.依赖注入\r\n\r\n## 6.1 构造器注入\r\n\r\n前面已经讲过了\r\n\r\n## ==6.2 Set方式注入==\r\n\r\n* 依赖注入:set注入\r\n  * 依赖:bean对象的创建依赖于容器\r\n  * 注入:bean对象的所有属性由容器注入\r\n\r\n### **[环境搭建]**\r\n\r\n#### 1.复杂类型\r\n\r\n```java\r\npackage com.hu.pojo;\r\n\r\nimport java.util.*;\r\n\r\npublic class Student {\r\n    /**value方式赋值*/\r\n    private String name;\r\n    /**ref 方式赋值*/\r\n    private Addresss addresss;\r\n    private String[] books;\r\n    private List<String> hobby;\r\n    private Map<String,String> card;\r\n    private Set<String> games;\r\n    private  String wife;\r\n    private Properties info;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Addresss getAddresss() {\r\n        return addresss;\r\n    }\r\n\r\n    public void setAddresss(Addresss addresss) {\r\n        this.addresss = addresss;\r\n    }\r\n\r\n    public String[] getBooks() {\r\n        return books;\r\n    }\r\n\r\n    public void setBooks(String[] books) {\r\n        this.books = books;\r\n    }\r\n\r\n    public List<String> getHobby() {\r\n        return hobby;\r\n    }\r\n\r\n    public void setHobby(List<String> hobby) {\r\n        this.hobby = hobby;\r\n    }\r\n\r\n    public Map<String, String> getCard() {\r\n        return card;\r\n    }\r\n\r\n    public void setCard(Map<String, String> card) {\r\n        this.card = card;\r\n    }\r\n\r\n    public Set<String> getGames() {\r\n        return games;\r\n    }\r\n\r\n    public void setGames(Set<String> games) {\r\n        this.games = games;\r\n    }\r\n\r\n    public String getWife() {\r\n        return wife;\r\n    }\r\n\r\n    public void setWife(String wife) {\r\n        this.wife = wife;\r\n    }\r\n\r\n    public Properties getInfo() {\r\n        return info;\r\n    }\r\n\r\n    public void setInfo(Properties info) {\r\n        this.info = info;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", addresss=\" + addresss +\r\n                \", books=\" + Arrays.toString(books) +\r\n                \", hobby=\" + hobby +\r\n                \", card=\" + card +\r\n                \", games=\" + games +\r\n                \", wife=\'\" + wife + \'\\\'\' +\r\n                \", info=\" + info +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.hu.pojo;\r\n\r\npublic class Addresss {\r\n    private String address;\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 2.配置文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n    <bean id=\"address\" class=\"com.hu.pojo.Addresss\">\r\n        <property name=\"address\" value=\"北京八大胡同\"/>\r\n    </bean>\r\n    <bean id=\"student\" class=\"com.hu.pojo.Student\">\r\n        <!--第一种,普通注入,value-->\r\n        <property name=\"name\" value=\"于谦\"></property>\r\n        <!--第二种, bean注入,ref-->\r\n        <property name=\"addresss\" ref=\"address\"/>\r\n        <!--第三种, 数组注入,array-->\r\n        <property name=\"books\">\r\n            <array>\r\n                <value>金瓶梅</value>\r\n                <value>金瓶梅彩页版</value>\r\n                <value>金瓶梅有声小说</value>\r\n                <value>金瓶梅名家解析全套</value>\r\n            </array>\r\n        </property>\r\n        <!--第四种, 列表注入,List-->\r\n        <property name=\"hobby\">\r\n            <list>\r\n                <value>抽烟</value>\r\n                <value>喝酒</value>\r\n                <value>烫头</value>\r\n            </list>\r\n        </property>\r\n        <!--第五种, map注入,map-->\r\n        <property name=\"card\">\r\n            <map>\r\n                <entry key=\"身份证\" value=\"123412345612345678\"/>\r\n                <entry key=\"银行卡\" value=\"932321456654789987\"/>\r\n            </map>\r\n        </property>\r\n        <!--第六种, set注入,set-->\r\n        <property name=\"games\">\r\n            <set>\r\n                <value>LOL</value>\r\n                <value>WOW</value>\r\n                <value>COC</value>\r\n                <value>BOB</value>\r\n            </set>\r\n        </property>\r\n        <!--NULL注入-->\r\n        <property name=\"wife\">\r\n            <null/>\r\n        </property>\r\n        <!--Properties注入-->\r\n        <property name=\"info\">\r\n            <props>\r\n                <prop key=\"学号\">20200409</prop>\r\n                <prop key=\"性别\">男</prop>\r\n                <prop key=\"姓名\">小米</prop>\r\n                <prop key=\"username\">root</prop>\r\n                <prop key=\"password\">123456</prop>\r\n            </props>\r\n        </property>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### [真实测试对象]\r\n\r\n```java\r\nimport com.hu.pojo.Student;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class MyTest {\r\n    public static void main(String[] args) {\r\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\r\n        Student student = (Student) context.getBean(\"student\");\r\n        System.out.println(student.toString());\r\n        /**输出:\r\n         * Student{name=\'于谦\',\r\n         * addresss=Addresss{住址=\'北京八大胡同\'},\r\n         * books=[金瓶梅, 金瓶梅彩页版, 金瓶梅有声小说, 金瓶梅名家解析全套],\r\n         * hobby=[抽烟, 喝酒, 烫头],\r\n         * card={身份证=123412345612345678,银行卡=932321456654789987},\r\n         * games=[LOL, WOW, COC, BOB], wife=\'null\',\r\n         * info={学号=20200409,性别=男, password=123456, 姓名=小米, username=root}}\r\n         */\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 6.3 拓展方式注入\r\n\r\n### 1. p命名空间\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       ##导入p空间约束##\r\n       xmlns:p=\"http://www.springframework.org/schema/p\"\r\n       xmlns:c=\"http://www.springframework.org/schema/c\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n    <!--P命名空间注入,可以直接注入简单属性的值: property-->\r\n    <bean id=\"user\" class=\"com.hu.pojo.User\" p:name=\"郭德纲\" p:age=\"50\"/>\r\n</beans>\r\n```\r\n\r\n\r\n\r\n### 2. c命名空间\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       <!--导入C空间约束-->\r\nxmlns:c=\"http://www.springframework.org/schema/c\"\r\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\nhttps://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n<!--C命名空间注入,可以构造器注入: construction-->\r\n<bean id=\"user2\" class=\"com.hu.pojo.User\" c:age=\"48\" c:name=\"于谦\"></bean>\r\n</beans>\r\n```\r\n\r\n\r\n\r\n**我们可以使用,C命名空间,P命名空间方式进行注入:**\r\n\r\n[官方解释](https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-p-namespace)\r\n\r\n### 3.测试\r\n\r\n```java\r\n@Test\r\npublic void test2(){\r\n    ApplicationContext context = \r\n        new ClassPathXmlApplicationContext(\"userBeans.xml\");\r\n    User user = context.getBean(\"user\", User.class);\r\n    System.out.println(user);\r\n}\r\n}\r\n```\r\n\r\n## 6.4 bean的作用域(bean scope)\r\n\r\n![image-20200409113939346](D:\\file\\Typora的文件夹\\image-20200409113939346.png)\r\n\r\n\r\n\r\n### 1. The Singleton Scope\r\n\r\n​	单例模式:bean同一类只创建一个对象\r\n\r\n**==单例模式(Spring默认模式)==**\r\n\r\n![image-20200409114030953](D:\\file\\Typora的文件夹\\image-20200409114030953.png)\r\n\r\n\r\n\r\n```xml\r\n<!--The Singleton Scope 单例模式-->\r\n<bean id=\"user1\" class=\"com.hu.pojo.User\" p:name=\"郭德纲\" p:age=\"50\" scope=\"singleton\"/>\r\n```\r\n\r\n### 2. The Singleton Scope\r\n\r\n==**原型模式:每次从bean中get的时候都会创建一个新对象**==\r\n\r\n![image-20200409114347914](D:\\file\\Typora的文件夹\\image-20200409114347914.png)\r\n\r\n```xml\r\n<!--The Singleton Scope 原型模式-->\r\n<bean id=\"user2\" class=\"com.hu.pojo.User\" c:age=\"48\" c:name=\"于谦\" scope=\"prototype\"/>\r\n```\r\n\r\n### 3. 其余的\r\n\r\n* request\r\n* session\r\n* application\r\n* websocket\r\n\r\n**只在web开发中用到**\r\n\r\n# 7.bean的自动装配\r\n\r\n* 自动装配是Spring满足bean依赖的一种方式\r\n  1. 在xml中现实的装配\r\n  2. 在java中显示的装配\r\n  3. ==隐式的自动装配bena[重要]==\r\n\r\n## 7.1 测试\r\n\r\n.环境搭建\r\n\r\n* 一个人有两个宠物\r\n\r\n## 7.2 ByName自动装配\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n    <bean id=\"cat\" class=\"com.hu.pojo.Cat\"></bean>\r\n    <bean id=\"dog\" class=\"com.hu.pojo.Dog\"></bean>\r\n    \r\n    <!--\r\n        会自动在对象上下文查找与自己对象set方法后面的值对应的bean id;\r\n          例如:public void setDog(Dog dog) {\r\n            this.dog = dog;\r\n            }set后是Dog  对应<bean id=\"dog\">\r\n    -->\r\n    <bean id=\"people\" class=\"com.hu.pojo.People\" autowire=\"byName\">\r\n        <property name=\"name\" value=\"于谦\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n## 7.3 ByType自动装配\r\n\r\n```xml\r\n<!--\r\n    会自动在对象上下文查找与自己对象set方法后面的类型对应的bean id;\r\n    条件:类型全局唯一\r\n    优点:bean id可省略\r\n    -->\r\n<bean id=\"people\" class=\"com.hu.pojo.People\" autowire=\"byName\">\r\n    <property name=\"name\" value=\"于谦\"/>\r\n</bean>\r\n```\r\n\r\n小结:\r\n\r\n* byname的使用要求保证所有bean的id唯一,并且这个bean需要和自动注入的set方法的值一致\r\n* bytype的使用要求保证所有bean的class唯一,并且这个bean需要和自动注入的属性类型一致\r\n\r\n## 7.4 使用注解实现自动装配\r\n\r\nJDK1.5开始 支持的注解,Spring2.5开始支持注解\r\n\r\n> The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.\r\n\r\n### **前置条件:**\r\n\r\n1. 导入约束: xmlns:context=\"http://www.springframework.org/schema/context\"\r\n2. ==配置注解支持: <context:annotation-config/>==\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <context:annotation-config/>\r\n\r\n</beans>\r\n```\r\n\r\n### 1. Autowired和Qualifier\r\n\r\n#### @Autowired\r\n\r\n直接在属性上使用即可,也可以在set方法上使用\r\n\r\n使用Autowired我们就可以不编写Set方法了,前提自动装配的属性在IoC(Spring)容器中存在,且符合byname要求\r\n\r\n```xml\r\n@Nullable 字段标记了注解,说明这个注解标记的字段可以为null\r\n```\r\n\r\n如果显示注明required属性为false,表示这个对象可以为null;否则不允许为空\r\n\r\n```java\r\npublic @interface Autowired {\r\n    boolean required() default true;\r\n}\r\n```\r\n\r\n测试代码\r\n\r\n```java\r\npublic class People {\r\n    //如果显示注明required属性为false,表示这个对象可以为null;否则不允许为空\r\n    @Autowired(required = false)\r\n    private Cat cat;\r\n    @Autowired\r\n    private Dog dog;\r\n    private String name;\r\n}\r\n```\r\n\r\n####  @Qualifier(value = \"****\")\r\n\r\n```xml\r\n<bean id=\"cat1\" class=\"com.hu.pojo.Cat\"></bean>\r\n<bean id=\"cat2\" class=\"com.hu.pojo.Cat\"></bean>\r\n\r\n<bean id=\"dog1\" class=\"com.hu.pojo.Dog\"></bean>\r\n<bean id=\"dog2\" class=\"com.hu.pojo.Dog\"></bean>\r\n\r\n<bean id=\"people\" class=\"com.hu.pojo.People\"/>\r\n<context:annotation-config/>\r\n```\r\n\r\n\r\n\r\n```java\r\npublic class People {\r\n\r\n    @Autowired\r\n    @Qualifier(value = \"cat1\")\r\n    private Cat cat;\r\n    @Autowired\r\n    @Qualifier(value = \"dog2\")\r\n    private Dog dog;\r\n    private String name;\r\n\r\n```\r\n\r\n**当使用@Autowired的配置环境较复杂时,**\r\n\r\n**可使用@Qualifier(value = \"\")指定一个唯一的对象注入;**\r\n\r\n### 2.Resource(name:\"\")\r\n\r\n​										--------这是一个java的注解\r\n\r\n1. **当bean的id 与属性名一致时,自动匹配;**\r\n2. **当bean的id 与属性名不一致时,如果类型唯一,也自动匹配;**\r\n3. **当上述条件无法达成时,可使用,name属性,根据id指定一个bean去自动匹配;****\r\n\r\n```java\r\npublic class People {\r\n    @Resource\r\n    private Cat cat;\r\n    @Resource\r\n    private Dog dog;\r\n    private String name;\r\n}\r\n```\r\n\r\n小结:\r\n\r\n@Resource与Autowired的区别\r\n\r\n* 都是完成自动装配功能,都可以放在属性字段上\r\n* @Autowired是通过ByType方式实现的\r\n* @Resource默认通过ByName方式,找不到名字,ByType实现,==**全都找不到时通常报错**==\r\n* 指向顺序不同:\r\n  * @Autowired通过ByType,@Resource默认通过ByName方式\r\n\r\n# 8.使用注解开发\r\n\r\n在spring4之后要使用注解开发,必须要帮助aop的包导入; \r\n\r\n![image-20200409153611185](D:\\Document\\File\\Typora的文件夹\\image-20200409153611185.png)\r\n\r\n使用主机需要注入context约束,增加注解的支持\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        https://www.springframework.org/schema/context/spring-context.xsd\">\r\n    <context:annotation-config/>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n\r\n## 1.bena\r\n\r\n\r\n\r\n## 2.属性如何注入\r\n\r\n```java\r\npackage com.hu.pojo;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport sun.misc.Contended;\r\n@Contended//等价于<bean id=\"user\" class=\"com.hu.pojo.User\"/>,contended --->组件\r\npublic class User {\r\n//    @Value(\"于谦\")//相当于<property name=\"name\" value=\"于谦\"/>\r\n    public String name;\r\n    @Value(\"于谦\")//相当于<property name=\"name\" value=\"于谦\"/>\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 3.衍生的注解\r\n\r\n**@Contended**有几个衍生注解,在我们的web开发中,会按照mvc三层架构分层\r\n\r\n* dao		          **[@Repository]**\r\n* server              **[@Service]**\r\n* controller        **[@Controller]**\r\n\r\n**这四个注解功能是==等价==,都代表将某个类注册到==Spring中装配==.**\r\n\r\n## 4.自动装配配置\r\n\r\n```\r\n##注解说明\r\n- @Autowired :自动装配通过类型.名字\r\n- @Qualifier :自动装配通过名字.类型\r\n- @Resource  :自动装配通过名字.类型\r\n- @Component :组件,放在类上,说明这个类被Spring管理了,就是bean;\r\n```\r\n\r\n```java\r\n@Contended//等价于<bean id=\"user\" class=\"com.hu.pojo.User\"/>,contended --->组件\r\n@Scope(\"prototype\")\r\npublic class User {\r\n//    @Value(\"于谦\")//相当于<property name=\"name\" value=\"于谦\"/>\r\n    public String name;\r\n    @Value(\"于谦\")//相当于<property name=\"name\" value=\"于谦\"/>\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 5.作用域\r\n\r\n@Scope(\"value\");           value---->singleton(单例模式)/prototype(原型模式)\r\n\r\n## 6.小结\r\n\r\nxml与注解\r\n\r\n* xml更万能,适用与任何场合,方便维护;\r\n* 注解,不是自己的类用不了,维护相对复杂\r\n\r\nxml与注解最佳实践:\r\n\r\n* xml只赋值管理bean\r\n\r\n* 注解只负责属性的注入\r\n\r\n* 我们在使用的过程中,只需要注意一个问题:\r\n  **<u>==注解生效需要开启注解支持==</u>**\r\n\r\n  * ```xml\r\n        <!--指定要扫描的包,包下的注解就会生效-->\r\n        <context:component-scan base-package=\"com.hu.pojo\"/>\r\n        <context:annotation-config/>\r\n    ```\r\n\r\n\r\n\r\n# 9. 基于Java配置Spring\r\n\r\n我们现在要完全不使用Spring的xml配置,全权交给Java来做;\r\n\r\nJavaConfig是Spring的一个子项目,在Spring4之后,他成为了核心功能\r\n\r\n\r\n\r\n## 实体类\r\n\r\n```java\r\npackage com.hu.pojo;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration//注册到Spring容器中,这也是@Component\r\n\r\npublic class User {\r\n\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n    @Value(\"于谦\")//属性注入值\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 配置文件\r\n\r\n```java\r\npackage com.hu.config;\r\n\r\nimport com.hu.pojo.User;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Import;\r\n\r\n/**\r\n * @author God\r\n */\r\n@Configuration//这个也会被注册到Spring容器中,因为它本身也是@Component\r\n@ComponentScan(\"com.hu.pojo\")//扫描包\r\n@Import(MyConfig2.class)//两个类导入成一个配置\r\npublic class MyConfig {\r\n    //注册一个bean,相当于之前的bean标签\r\n    //方法名字相当于,bean id\r\n    //返回值相当于,bean中的class属性\r\n    //class:bean对象所对应的全限定类名\r\n    //<bean id=\"userT\" class=\"com.hu.pojo.UserT\" name=\"user2 u2,U2;utwo\"></bean>\r\n\r\n    @Bean\r\n    public User getUser(){\r\n        //  return new User(); 就是返回要注入到bean的对象\r\n        return new User();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 测试类\r\n\r\n```java\r\nimport com.hu.config.MyConfig;\r\nimport com.hu.pojo.User;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\n\r\nimport java.applet.AppletContext;\r\n\r\npublic class MyTest {\r\n    public static void main(String[] args) {\r\n        //如果完全使用了配置类方式去做,我们就只能通过AnnotattionConfig 上下文来获取容器,通过配置类的class对象加载\r\n        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);\r\n        User getUser = (User) context.getBean(\"getUser\");\r\n        System.out.println(getUser.getName());\r\n    }\r\n}\r\n\r\n```\r\n\r\n这种纯Java的配置方式,在SpringBoot中随处可见\r\n\r\n# 10. 代理模式\r\n\r\n为什么学习代理模式?因为这就是SpringAOP的底层; [面试必问SpringAOP和SpringMVC];\r\n\r\n代理模式分类\r\n\r\n* 静态代理\r\n* 动态代理\r\n\r\n![image-20200409194012134](D:\\file\\Typora的文件夹\\image-20200409194012134.png)\r\n\r\n## 10.1 静态代理\r\n\r\n角色分析:\r\n\r\n* 抽象角色:一般使用接口或者抽象类解决\r\n* 真实角色: 被代理的角色 \r\n* 代理角色: 代理真实角色.代理真实角色后,一般也做一些附属操作\r\n* 客户:访问代理对象的人.(用户)\r\n\r\n代码步骤\r\n\r\n1.抽象角色		             (接口抽象出来){**核心业务**,业务接口}\r\n\r\n```java\r\npackage com.hu.demo01;\r\n//租房\r\npublic interface Rent {\r\n    public void rent();\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n2.真实角色                     {业务类,**逻辑代码**的存放类,继承接口}\r\n\r\n```java\r\npackage com.hu.demo01;\r\n\r\n//房东\r\npublic class Host implements Rent {\r\n\r\n    public void rent() {\r\n        System.out.println(\"房东要出租房子\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n3.代理角色                     {中转站,**实现前后端分离**的中间层}\r\n\r\n```java\r\npackage com.hu.demo01;\r\n\r\npublic class Proxy implements Rent {\r\n    private Host host;\r\n\r\n    public Proxy() {\r\n    }\r\n\r\n    public Proxy(Host host) {\r\n        this.host = host;\r\n    }\r\n\r\n\r\n    //代理的事情\r\n    public void rent() {\r\n        seeHouse();\r\n        host.rent();\r\n        hetong();\r\n        tips();\r\n    }\r\n    //附属操作\r\n    public void seeHouse(){\r\n        System.out.println(\"带你看房\");\r\n    }\r\n    public void tips(){\r\n        System.out.println(\"收取中介费\");\r\n    }\r\n    public void hetong(){\r\n        System.out.println(\"签合同\");\r\n    }\r\n}\r\n```\r\n\r\n4.客户端访问代理角色  {客户,**用户**,使用业务功能的人}\r\n\r\n```java\r\npackage com.hu.demo01;\r\n\r\npublic class Client {\r\n    //租客找房东\r\n    public static void main(String[] args) {\r\n        Host host =new Host();\r\n        //代理,中介帮房东租房子,但是代理角色一般有一些附属操作!\r\n        Proxy proxy=new Proxy(host);\r\n        //你不同面对房东,直接找中介租房即可\r\n        proxy.rent();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n代理模式的好处:\r\n\r\n1. 可以使真实角色的操作更加纯粹,不必去关注公共业务\r\n2. 公共业务交给代理角色,实现业务的**分工**\r\n3. 公共业务**扩展时**,方便**集中管理**\r\n\r\n缺点:\r\n\r\n* 一个真实角色产生一个代理角色;代码量翻倍,开发效率降低;\r\n\r\n## 10.2 加深理解\r\n\r\n###  1 聊聊AOP\r\n\r\n![image-20200410102028899](D:\\file\\Typora的文件夹\\image-20200410102028899.png)\r\n\r\n业务接口:\r\n\r\n已经完成的业务\r\n\r\n```java\r\npackage com.hu.demo02;\r\n\r\npublic interface UserService {\r\n    public void add();\r\n    public void delete();\r\n    public void update();\r\n    public void query();\r\n\r\n\r\n}\r\n```\r\n\r\n业务实现类\r\n\r\n​	实现业务的类\r\n\r\n```java\r\npackage com.hu.demo02;\r\n\r\npublic class UserServiceImpl implements UserService {\r\n    public void add() {\r\n        System.out.println(\"增加一个用户\");\r\n    }\r\n\r\n    public void delete() {\r\n        System.out.println(\"删除一个用户\");\r\n    }\r\n\r\n    public void update() {\r\n        System.out.println(\"修改一个用户\");\r\n    }\r\n\r\n    public void query() {\r\n        System.out.println(\"查询一个用户\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n代理对象,完成业务+附加的新功能\r\n\r\n```java\r\npackage com.hu.demo02;\r\n\r\npublic class UserServiceProxy implements UserService {\r\n    private UserServiceImpl userService;\r\n\r\n    public void setUserService(UserServiceImpl userService) {\r\n        this.userService = userService;\r\n    }\r\n\r\n    public void add() {\r\n        Log(\"add\");\r\n        System.out.println(\"增加一个用户\");\r\n    }\r\n\r\n    public void delete() {\r\n        Log(\"delete\");\r\n        System.out.println(\"删除一个用户\");\r\n    }\r\n    public void update() {\r\n        Log(\"update\");\r\n\r\n        System.out.println(\"修改一个用户\");\r\n    }\r\n\r\n    public void query() {\r\n        Log(\"query\");\r\n        System.out.println(\"查询一个用户\");\r\n    }\r\n    //附加功能\r\n    public void Log(String msg){\r\n        System.out.println(\"使用了\"+msg+\"方法\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n客户端\r\n\r\n```java\r\npackage com.hu.demo02;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //实际对象\r\n        UserServiceImpl userService =new UserServiceImpl();\r\n\r\n\r\n        //代理对象实现功能\r\n        UserServiceProxy proxy=new UserServiceProxy();\r\n        proxy.setUserService(userService);\r\n        proxy.add();\r\n    }\r\n}\r\n```\r\n\r\n## 10.3 动态代理\r\n\r\n* 动态代理和静态代理角色一样\r\n* 动态代理代理类,是动态生成的不是我们写好的\r\n* 动态代理分为两大类:基于接口的动态代理,基于类的动态代理\r\n  * **基于接口----JDK动态代理**			==[学习]==\r\n  * 基于类------cglib\r\n  * java字节码:Javassist\r\n\r\n需要了解两个类:Proxy代理和InvocationHandler:调用处理程序\r\n\r\n**InvocationHandler**:调用实例的实现接口,关联调用程序\r\n\r\n**Proxy**:提供创建动态代理类的静态方法\r\n\r\n```java\r\n//抽象成的态代理工具类\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n//InvocationHandler:调用实例的实现接口,关联调用程序\r\npublic class ProxyInvocationHandler implements InvocationHandler {\r\n\r\n    //被代理的接口\r\n    private Object target;\r\n\r\n    public void setTarget(Object target) {\r\n        this.target = target;\r\n    }\r\n\r\n    //生成得到代理类\r\n    public Object getProxy() {\r\n        //Proxy:提供创建动态代理类的静态方法\r\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(),\r\n                target.getClass().getInterfaces(), this);\r\n    }\r\n\r\n    //处理代理实例,并返回结果\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        //动态代理的本质.就是使用反射机制\r\n        log(method.getName());\r\n        Object result = method.invoke(target, args);\r\n        return result;\r\n    }\r\n    public void log(String msg){\r\n        System.out.println(\"执行了\"+msg+\"方法\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n### 总结:\r\n\r\n1. 可以使真实角色的操作更加纯粹,不必去关注公共业务\r\n2. 公共业务交给代理角色,实现业务的**分工**\r\n3. 公共业务**扩展时**,方便**集中管理**\r\n4. 一个动态代理类代理的是一个接口.一般就是对应的一类业务;\r\n5. 一个动态代理类可以代理多个类,只要是实现了同一个接口\r\n\r\n# 11.AOP\r\n\r\n## 1.什么是AOP?\r\n\r\n![image-20200419120410312](image-20200419120410312.png)\r\n\r\n## 2.AOP在Spring中的作用\r\n\r\n![image-20200419120609665](image-20200419120609665.png)\r\n\r\n![image-20200419120649122](image-20200419120649122.png)\r\n\r\n![image-20200419121419972](image-20200419121419972.png)\r\n\r\n## 3.使用Spring实现Aop\r\n\r\n前提:导入AOP依赖包\r\n\r\n```JavaScript\r\n<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->\r\n<dependency>\r\n    <groupId>org.aspectj</groupId>\r\n    <artifactId>aspectjweaver</artifactId>\r\n    <version>1.9.5</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n方式一:使用Spring API接口\r\n\r\n方式二:使用自定义类实现aop\r\n\r\n\r\n\r\n# 12 整合mybatis\r\n\r\n步骤:\r\n\r\n1. 导入jar包\r\n   * junit\r\n   * mybatis\r\n   * mysql数据库\r\n   * spring相关包\r\n   * aop织入\r\n   * mybatis-spring**[new]**\r\n2. 编写配置文件\r\n\r\n```xml\r\n<dependencies>\r\n    <!-- https://mvnrepository.com/artifact/junit/junit -->\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.13</version>\r\n        <scope>test</scope>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.47</version>\r\n    </dependency>\r\n    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\r\n    <dependency>\r\n        <groupId>org.mybatis</groupId>\r\n        <artifactId>mybatis</artifactId>\r\n        <version>3.5.4</version>\r\n    </dependency>\r\n    <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\r\n    <!--spring.jar包导入-->\r\n    <dependency>\r\n        <groupId>org.springframework</groupId>\r\n        <artifactId>spring-webmvc</artifactId>\r\n        <version>5.2.0.RELEASE</version>\r\n    </dependency>\r\n    <!--        spring操作数据库还需要spring-jdbc这个包-->\r\n    <!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\r\n    <dependency>\r\n        <groupId>org.springframework</groupId>\r\n        <artifactId>spring-jdbc</artifactId>\r\n        <version>5.2.0.RELEASE</version>\r\n    </dependency>\r\n    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->\r\n    <dependency>\r\n        <groupId>org.mybatis</groupId>\r\n        <artifactId>mybatis-spring</artifactId>\r\n        <version>2.0.4</version>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n3. 测试\r\n\r\n## 12.1 回忆mybatis\r\n\r\n1. 编写实体类\r\n2. 编写核心配置文件\r\n3. 编写接口\r\n4. 编写Mapper.xml\r\n5. 测试\r\n\r\n\r\n\r\n## 12.2 mybatis-spring\r\n\r\n1. 编写数据源\r\n2. sqlSessionFactory\r\n3. sqlSessionTemplate\r\n4. 给接口加实现类[new]\r\n5. 将自己写的实现类注入到spring中\r\n6. 测试使用\r\n\r\n## 12.3 声明式事务\r\n\r\n## 1.回顾事务\r\n\r\n* 把一组业务合成一个事务;要么都成功,要么都失败\r\n* 事务在项目开发中十分重要,涉及数据一致性问题\r\n* 确保完整性和一致性\r\n\r\n**1.1 事务的ACID原则**\r\n\r\n* **原子性**\r\n* **一致性**\r\n* **隔离性**\r\n  * 多个业务可能操作同一个资源,保证各个业务操作隔离,防止数据损坏\r\n* **持久性**\r\n  * 事务一旦提交,无论系统发生什么问题,结果都不会影响,被持久性的写入存储器中\r\n\r\n## 2. spring中的事务管理\r\n\r\n* 声明式事务:AOP\r\n* 编程式事务:需要在代码中,进行事务管理;(记录回滚)\r\n\r\nSpring中七种事务传播行为\r\n\r\n| 事务传播行为类型          | 说明                                                         |\r\n| ------------------------- | ------------------------------------------------------------ |\r\n| PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。==spring中默认的类型== |\r\n| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |\r\n| PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常。               |\r\n| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。                 |\r\n| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |\r\n| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |\r\n| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |\r\n\r\n思考:为什么需要事务?\r\n\r\n* 如果不存在事务,可能存在数据提交不一致的情况;\r\n* 如果我们不在spring配置声明事务,我们就需要在代码中手动添加事务', '2020-06-11 05:23:29', 'spring框架学习', 'https://images.unsplash.com/photo-1561146251-28c56dcc116f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'spring框架学习', '2020-04-21 05:23:29', 1, 65, 1, 0);
INSERT INTO `t_blog` VALUES (71, b'1', b'1', '微服务阶段\r\n\r\n\r\n\r\nJavaSE :OOP\r\n\r\nmysql:持久化\r\n\r\nhtm+css+js+jQuery+框架  :视图,框架不熟.CSS不好\r\n\r\njavaWeb:独立开发MVC三层架构网站:原始\r\n\r\nSSM:框架:简化开发流程,配置开始复杂\r\n\r\nWar:Tomcat运行\r\n\r\nSpring再件shua:springBoot:jar:内嵌Tomcat:微服务框架\r\n\r\n服务越来越多:SpringCloud\r\n\r\n\r\n\r\n微服务是一种架构风格\r\n\r\nMVC三层架构\r\n\r\nMVVM 微服务架构\r\n\r\n\r\n\r\n业务:service:UserService:===>模块\r\n\r\nspringmvc,controller===>提供接口!\r\n\r\n\r\n\r\n程序=数据结构+算法; 程序员\r\n\r\n程序=面向对象+框架; 码农\r\n\r\n\r\n\r\n# 环境要求\r\n\r\n* jdk 1.8\r\n* maven3.6.1\r\n* springboot 最新版\r\n* idea\r\n\r\n官方:提供了一个快速生产的网站!idea集成了这个网站\r\n\r\nidea:新建\r\n\r\n# 原理初探\r\n\r\n自动配置\r\n\r\npom.xml\r\n\r\n* spring-boot-dependencies:核心依赖在父工程\r\n* 我们在写或引入一些springboot依赖的时候,不需要指定版本,因为有这些版本仓库\r\n\r\n启动器\r\n\r\n* ```xml\r\n  <dependency>\r\n      <groupId>org.springframework.boot</groupId>\r\n      <artifactId>spring-boot-starter-web</artifactId>\r\n  </dependency>\r\n  ```\r\n\r\n  * 启动器:说白了就是springboot的启动场景\r\n  * 比如spring-boot-starter-web,就会自动导入web环境所有依赖\r\n  * springboot将所有功能场景都编程为一个个启动器\r\n  * 要使用什么功能就只需要依赖对应的启动器\r\n\r\n主程序\r\n\r\n```java\r\n@SpringBootApplication\r\npublic class Springboot01HelloworldApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(Springboot01HelloworldApplication.class, args);\r\n    }\r\n\r\n}\r\n```\r\n\r\n注解:\r\n\r\n* @SpringBootApplication:是一个启动类;表明这是一个SpringBoot程序,启动类下的所有资源陪导入\r\n\r\n* ```java\r\n  @SpringBootConfiguration	//springboot的配置\r\n  	@Configuration	//spring配置类\r\n  		@component  //组件\r\n  @EnableAutoConfiguration	//自动配置\r\n  	@AutoConfigurationPackage //自动配置包\r\n  		@Import({Registrar.class}) //自动配置\'包注册\'\r\n  	@Import({AutoConfigurationImportSelector.class}) //自动配置导入选择\r\n  \r\n  //获取所有配置\r\n    List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\r\n  	\r\n  ```\r\n\r\n  \r\n\r\n获取候选的配置\r\n\r\nMETA-INF/spring.factories:自动配置核心文件\r\n\r\n![image-20200430120757214](image-20200430120757214.png)\r\n\r\nspringboot的所有的自动配置都是在启动的时候被扫描并加载,但不一定生效,需要判断条件是否成立,只要成立自动装配就会生效,然后配置成功.\r\n\r\n1. springboot在启动的时候,从路径下/META-INF/spring.factories获取指定的值\r\n2. 将这些自动配置的类导入容器,自动配置就会生效,帮我们自动配置!\r\n3. 以前需要我们自动配置的东西,现在springboot帮我们做了\r\n4. 整合JavaEE,解决方案和自动配置的东西都在spring-boot-autoconfigure-2.20.RELEASE.jar这个包下\r\n5. 他会把所有需要导入的组件,以类名的方式返回,组件就会被添加到容器\r\n6. 容器中也会存在很多xxxAutoConfiguration的文件(@bean),就是这些类给容器导入了这个场景需要的组件;并自动装配,@Configuration JavConfig!\r\n7. 有了自动装配类,免去了我们收到编写配置文件的工作\r\n\r\nSpringApplication类做了以下四件事情\r\n\r\n1. 推断应用的类型是普通的项目还是web项目\r\n2. 查找斌加载所有可用的初始化器,设置到initializers属性中\r\n3. 找不所有的应用程序监听器,设置到listeners属性中\r\n4. 推断并shezhimain方法的定义类,找到运行的主类\r\n\r\n# yaml配置\r\n\r\n* 可以给实体类赋值\r\n* 基本语法\r\n\r\n```yaml\r\n#特性:给实体类赋值\r\n#基本语法:\r\n#k=v\r\n#普通key -value\r\nname: qinjiang\r\n#对象\r\nstudent:\r\n  name: qinjiang\r\n  age: 3\r\n\r\n#行内写法\r\nstudent1: {name: qinjiang,age: 3}\r\n\r\n#数组\r\npet:\r\n  - cat\r\n  - dog\r\n  - pig\r\n\r\n#数组行内写法\r\npets: {cat,dog,pig}\r\n```\r\n\r\n@ConfigurationProperties\r\n\r\n* 将配置文件中配置的每一个属性,映射到组件中\r\n* 告诉springboot将本类中的所有属性和配置文件中相关的配置进行绑定\r\n* 参数prefix=\"preson\":将配置文件person下面的属性一一对应\r\n* 只有这个组件是容器中的租价才能使用容器提供的@ConfigurationProperties功能\r\n\r\n这个配置文件能配置的东西,都存在一个xxxpropertiesConfiguration:默认值\r\n\r\n xxxProperties配置文件绑定\r\n\r\n# ==自动装配原理==\r\n\r\n![image-20200430192858394](image-20200430192858394.png)\r\n\r\n# JSR303\r\n\r\n@Vaildated--在类上使用开启功能\r\n\r\n以下在属性上使用:限制注入\r\n\r\n| **Constraint**                | **详细信息**                                             |\r\n| :---------------------------- | :------------------------------------------------------- |\r\n| `@Null`                       | 被注释的元素必须为 `null`                                |\r\n| `@NotNull`                    | 被注释的元素必须不为 `null`                              |\r\n| `@AssertTrue`                 | 被注释的元素必须为 `true`                                |\r\n| `@AssertFalse`                | 被注释的元素必须为 `false`                               |\r\n| `@Min(value)`                 | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\r\n| `@Max(value)`                 | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\r\n| `@DecimalMin(value)`          | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\r\n| `@DecimalMax(value)`          | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\r\n| `@Size(max, min)`             | 被注释的元素的大小必须在指定的范围内                     |\r\n| `@Digits (integer, fraction)` | 被注释的元素必须是一个数字，其值必须在可接受的范围内     |\r\n| `@Past`                       | 被注释的元素必须是一个过去的日期                         |\r\n| `@Future`                     | 被注释的元素必须是一个将来的日期                         |\r\n| `@Pattern(value)`             | **==被注释的元素必须符合指定的正则表达式==**(核心)       |\r\n\r\n| **Constraint** | **详细信息**                           |\r\n| :------------- | :------------------------------------- |\r\n| `@Email`       | 被注释的元素必须是电子邮箱地址         |\r\n| `@Length`      | 被注释的字符串的大小必须在指定的范围内 |\r\n| `@NotEmpty`    | 被注释的字符串的必须非空               |\r\n| `@Range`       | 被注释的元素必须在合适的范围内         |\r\n\r\n# springboot	web开发\r\n\r\njar : webapp\r\n\r\n自动装配\r\n\r\nspringboot到底帮助我们配置了什么?我们能不能修改?能修改哪些东西?能不能扩展?\r\n\r\n* xxxAutoConfiguration..向容器中自动配置组件\r\n* xxxProperties:自动配置类,装配配置文件中自定义的一些内容\r\n\r\n要解决的问题\r\n\r\n* 导入静态资源\r\n* 首页\r\n* jsp,模板引擎Thymeleaf\r\n* 装配扩展SpringMVC\r\n* CURD\r\n* 拦截器\r\n* 国际化\r\n\r\n## 1.导入静态资源\r\n\r\n```java\r\n@Override\r\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n    \r\n    if (!this.resourceProperties.isAddMappings()) {\r\n        logger.debug(\"Default resource handling disabled\");\r\n        return;\r\n    }\r\n    \r\n    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\r\n    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\r\n    if (!registry.hasMappingForPattern(\"/webjars/**\")) {\r\n        customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\")\r\n                                             .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\r\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\r\n    }\r\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\r\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\r\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\r\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\r\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\r\n    }\r\n}\r\n```\r\n\r\n### 1.什么是/webjars?\r\n\r\n/webjars映射了classpath:/WETA-INF/resources/webjars/路径\r\n\r\n### 2.方式2\r\n\r\n在\r\n\r\n**classpath:resources;** \r\n\r\n**classpath: public;** \r\n\r\n**classpath:/META-INF/resources;**  (==就是webjars的目录==)\r\n\r\n**classpath: statics;**\r\n\r\n四个目录下的都可以访问到\r\n\r\n### 总结\r\n\r\n在springboot中我们可以采用以下方式处理静态资源\r\n\r\n* webjars   `localhost:8080/webjars/**`\r\n* public\r\n* statics\r\n* /**      (==根目录下的所有资源==)\r\n* resources\r\n\r\n**优先级**: resources>static==(默认)==>public\r\n\r\n## 2.首页如何定制\r\n\r\n在目录下的:index.html\r\n\r\n* public\r\n\r\n  statics\r\n\r\n  /**      (==根目录下的所有资源==)\r\n\r\n  resources\r\n\r\n## 3.模板引擎\r\n\r\ntemplates:目录下的资源只能通过Controller访问相当于WEB-INF\r\n\r\n结论:只要需要用thymeleaf,只需要导入对应依赖就可以了,我们把html放在classpath:templates目录下\r\n\r\n### thymeleaf:语法\r\n\r\nhttps://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html\r\n\r\n* ${...}普通变量\r\n* #{...}国际化消息\r\n* @{...}传url\r\n* ~{...}片段表达式\r\n\r\n\r\n\r\n* \'....\'  文本 \r\n* 1,2,3 数字直接写\r\n* 布尔值 true false\r\n* 空值  null\r\n\r\n\r\n\r\n* 文本操作 +\r\n\r\n![image-20200501101036276](image-20200501101036276.png)\r\n\r\n在springboot,有非常多的XXXConfiguration(配置类)会帮助镜像扩展配置,只要配置类就要注意他扩展了什么功能\r\n\r\nXXXConfiguration==(配置类)==\r\n\r\nXXXAutoConfiguration ==(自动配置)==', '2020-06-11 05:25:27', '了解springboot，探索springboot与spring的异同，并了解spring boot新增功能', 'https://images.unsplash.com/photo-1591693971635-7541a48405fd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', '了解SpringBoot', '2020-06-11 05:25:27', 1, 68, 1, 0);
INSERT INTO `t_blog` VALUES (72, b'1', b'1', '一、安装本地Maven\r\n点此进入maven官网下载\r\n\r\n然后配置path环境变量\r\n系统变量:MAVEN_HOME = F:\\dev\\apache-maven-3.6.1\r\n系统变量:path = %MAVEN_HOME%\\bin\r\nMAVEN_HOME:\r\npath:\r\n然后win+R 运行cmd 输入 mvn -version\r\n二、配置settings文件\r\n在F:\\dev\\apache-maven-3.6.1\\conf下可以找到settings文件，打开(嫌麻烦的直接看最后一步)\r\n\r\n找到第52行，这里是maven默认的仓库\r\n\r\n我们复制第53行\r\n<localRepository>/path/to/local/repo</localRepository>\r\n1\r\n将它拿到注释外并将中间的内容改成你需要的路径，如图\r\n<localRepository>F:/repository</localRepository>\r\n1\r\n这里的路径随便设置，注意这里是正斜杠\r\n因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning)\r\n <!-- 阿里云仓库 -->\r\n        <mirror>\r\n            <id>alimaven</id>\r\n            <mirrorOf>central</mirrorOf>\r\n            <name>aliyun maven</name>\r\n            <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\r\n        </mirror>\r\n     或者\r\n      <mirror>\r\n		<id>nexus-aliyun</id>\r\n		<mirrorOf>*</mirrorOf>\r\n        <name>Nexus aliyun</name>\r\n        <url>http://maven.aliyun.com/nexus/content/groups/public</url>\r\n	 </mirror>\r\n	 \r\n，要夹在两个mirrors标签之间\r\n\r\n\r\n在最后配置jdk，也要夹在两个profiles标签之间\r\n\r\n<!—java版本 --> \r\n<profile>\r\n      <id>jdk-1.8</id>\r\n      <activation>\r\n	    <activeByDefault>true</activeByDefault>\r\n        <jdk>1.8</jdk>\r\n      </activation>\r\n\r\n      <properties>\r\n        <maven.compiler.source>1.8</maven.compiler.source>\r\n		<maven.compiler.target>1.8</maven.compiler.target>\r\n		<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\r\n      </properties>\r\n</profile>\r\n配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功\r\n\r\n嫌麻烦的直接复制配置文件的内容即可,不过路径还是要改(参考第3步)\r\n', '2020-06-11 05:29:30', 'Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。\r\nMaven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 ', 'https://images.unsplash.com/photo-1591686224641-2e07b13c0b51?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'Maven', '2020-06-11 05:29:30', 1, 69, 1, 0);
INSERT INTO `t_blog` VALUES (73, b'1', b'1', '# 1. SpringMVC概述\r\n\r\nSSM:mybatis+spring+SpringMVC\r\n\r\nJavaSE:认真学习;老师带,入门快\r\n\r\nJavaWeb:认真学习;老师带,入门快\r\n\r\n框架:研究官方文档,锻炼自学能力,锻炼笔记能力,锻炼项目能力;\r\n\r\nSpringMVC +Vue+sSpringBoot+SpringCloud+Linux\r\n\r\nSSM=JavaWeb做项目;\r\n\r\nspring:ioc和aop\r\n\r\n\r\n\r\n==SpringMVC: SpringMVC的执行流程==\r\n\r\nSpringMVC:SSM框架的整合\r\n\r\n\r\n\r\nsping\r\n\r\n\r\n\r\n## ==1.MVC是什么?==\r\n\r\nMVC=model(模型:doa层,service层)+view(视图:jsp)+control(控制器:servlet)\r\n\r\n**M:数据和业务** model\r\n\r\n**C:交接** Controller\r\n\r\n**V:HTML CSS** View\r\n\r\n## ==2.MVC分别有什么功能?==\r\n\r\ncontrol\r\n\r\n* 取得表单数据\r\n* 调用业务逻辑\r\n* 转向指定页面\r\n\r\nmodel\r\n\r\n* 业务逻辑\r\n* 保存数据状态\r\n\r\nview\r\n\r\n* 显示页面\r\n\r\ndao:连接数据库\r\n\r\nservice:调动dao层执行业务\r\n\r\nservlet:接收前端数据,交给service处理   (转发/重定向)\r\n\r\njsp/html:\r\n\r\n\r\n\r\n\r\n\r\n前端 + 数据传输 + 实体类\r\n\r\n实体类:用户名,密码,生日,爱好,....20个\r\n\r\n前端:登录业务只需要:用户名,密码\r\n\r\n\r\n\r\npojo:User:20+属性\r\n\r\nvo:UserVo:业务需要的属性\r\n\r\ndto:\r\n\r\n\r\n\r\nJSP:本质就是一个servlet\r\n\r\nMVC框架要做哪些事情?\r\n\r\n1. 把URL映射到Java类或Java类的方法\r\n2. 封装用户提交的数据\r\n3. 处理请求--调用相关的业务处理--封装响应数据\r\n4. 将响应的数据进行渲染.(jsp/html的表述层输出)\r\n\r\n## 3.新建一个SpringMVC\r\n\r\n1. web.xml注册DispatcherServlet\r\n2. \r\n\r\n\r\n\r\n![image-20200422150310255](image-20200422150310255.png)\r\n\r\n![image-20200427105034545](image-20200427105034545.png)\r\n\r\n\r\n\r\n# 2.简要分析执行流程\r\n\r\n1.DispatcherServlet表示前端控制器,是整个SpringMVC的控制中心,用户发出请求.DispatcherServlet接收请求病拦截请求\r\n\r\n* 假设我们请求的url为:https://localhost:8080/SpringMVC/hello\r\n* 如上的url拆分成三部分\r\n  * https://localhost:8080 ------ 服务器域名\r\n  * SpringMVC-----部署在服务器上的web站点\r\n  * hello --------- 控制器\r\n\r\n![image-20200422143527506](image-20200422143527506.png)\r\n\r\n\r\n\r\n1. 发起请求\r\n2. 找DispatcherServlet         (DispatcherServlet在==web.xml中配置==)\r\n3. DispatcherServlet需要绑定配置文件              (配置文件:==springmvc-servlet.xml==)\r\n4. 处理器映射器---HandlerMapper                         (HandlerMapper在==springmvc-servlet.xml==中配置)\r\n5. url中的/hello控制器在HanderMapper下找到对应的HelloController类;\r\n6. 处理器适配器找到HelloController来处理\r\n7. HelloController调用实际业务来处理业务==返回一个ModelAndView==\r\n8. ModelAndView交给视图解析器,视图解析器返回给DispatcherServlet\r\n9. 用户接收请求到的页面\r\n\r\n\r\n\r\n### 1.使用SpringMVC必须配置的三大件\r\n\r\n实现注解开发的步骤:\r\n\r\n* 新建web项目\r\n* 导入相关jar包\r\n* 编写web.xml.配置DispatcherServlet\r\n* 编写SpringMVC配置文件\r\n* ==创建对应的控制类==,controller\r\n* 完善==前端视图==与==controller==之间的==对应==\r\n* 运行测试\r\n\r\n1. 处理器映射器\r\n2. 处理器适配器\r\n3. 视图解析器\r\n\r\n通常我们==只==需要==手动配置==    ==视图解析器==,而**处理器映射器**和**处理器适配器**只需要开启==注释驱动==即可,省去了大量xml配置\r\n\r\n@Component 组件\r\n\r\n@Service \r\n\r\n@Controller \r\n\r\n@Repository\r\n\r\n\r\n\r\n\r\n\r\n前后端分离时代: \r\n\r\n后端部署后端,提供接口\r\n\r\n\r\n\r\n​			json\r\n\r\n\r\n\r\n前端独立部署,负责渲染数据\r\n\r\n# 3.JSON是什么?\r\n\r\nJSON(JavaScript Object Notation)是一种轻量级的数据交换格式，它基于JavaScript的一个子集，易于人的编写和阅读，也易于机器解析。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。\r\n\r\n', '2020-06-11 05:30:25', 'SpringMVC学习掌握', 'https://images.unsplash.com/photo-1591740383838-18b6fc0d75ec?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '', b'1', b'1', b'1', 'SpringMVC', '2020-06-11 05:30:25', 3, 66, 1, 3);
INSERT INTO `t_blog` VALUES (74, b'1', b'1', '# 1.什么是CSS\r\n\r\n1. CSS学习\r\n\r\n如何学习\r\n\r\n1. CSS是什么?\r\n2. CSS怎么用?\r\n3. **CSS选择器**(重点+难点)\r\n4. 美化页面(文字,阴影,超链接,列表,渐变...)\r\n5. 盒子模型(div)\r\n6. 浮动\r\n7. 定位\r\n8. 网页动画\r\n\r\n## 1.1什么是CSS?\r\n\r\nCascading Style Sheet:层叠(级联)样式表\r\n\r\nCSS:表现:(美化网页)\r\n\r\n![image-20200414124524081](image-20200414124524081.png)\r\n\r\n\r\n\r\n## 1.2 CSS发展史\r\n\r\nCSS1.0\r\n\r\nCSS2.0	DIV(块)+CSS,HTML与CSS结构分离思想	SEO\r\n\r\nCSS2.1	浮动,定位\r\n\r\nCSS3.0	圆角,阴影,动画...产生浏览器兼容性问题\r\n\r\n## 1.3 快速入门\r\n\r\nstyle :\r\n\r\n建议使用的方式:\r\n\r\n![image-20200414125104166](image-20200414125104166.png)\r\n\r\nCSS优势\"\r\n\r\n1. 内容与表现分离\r\n2. 网页结构表现同意,可以实现复用\r\n3. 样式十分丰富\r\n4. 建议使用独立html的CSS文件\r\n5. 利用SEO,容易被搜索引擎收录\r\n\r\n## 1.4 CSS的三种导入方式\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>我是标题</title>\r\n    <!--内部样式----标签样式-->\r\n    <style>\r\n        h1{\r\n            color: green;\r\n        }\r\n    </style>\r\n    <link rel=\"stylesheet\" href=\"CSS/style.css\">\r\n</head>\r\n<body>\r\n<!--内部样式---行内样式-->\r\n<h1 style=\"color: blue\">我是标题</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n```css\r\n/*外部样式*/\r\nh1{\r\n    color: yellowgreen;\r\n}\r\n```\r\n\r\n扩展:外部样式两种写法:\r\n\r\n* 链接式\r\n\r\n  * ```css\r\n    <!--链接式-->\r\n    <link rel=\"stylesheet\" href=\"CSS/style.css\">\r\n    ```\r\n\r\n* 导入式:CSS2.1特有的\r\n\r\n  * ```css\r\n    <style>\r\n        /*导入式*/\r\n        @import \"CSS/style.css\";\r\n    </style>\r\n    ```\r\n\r\n# 2.选择器\r\n\r\n> 作用:用于选择页面上的某个或某类元素\r\n\r\n## ==2.1 三种基本选择器==\r\n\r\n1. 标签选择器\r\n\r\n   * 当前页面所有标签一起改变\r\n\r\n   * ```html\r\n     <!DOCTYPE html>\r\n     <html lang=\"en\">\r\n     <head>\r\n         <meta charset=\"UTF-8\">\r\n         <title>Title</title>\r\n         <style>\r\n             /*标签选择器会选择到页面上所有这类标签*/\r\n             h1{\r\n                 color: green;\r\n             }\r\n             p{\r\n                 font-size: 80px;\r\n             }\r\n         </style>\r\n     </head>\r\n     <body>\r\n     <h1>学Java-1</h1>\r\n     <h1>学Java-2</h1>\r\n     <p>听于谦说</p>\r\n     </body>\r\n     </html>\r\n     ```\r\n\r\n2. 类 选择器 class\r\n\r\n   * 类选择器样式: --------------- .class的名称{}; 可以多个标签归类,是同一个class\r\n\r\n   * ```html\r\n     <!DOCTYPE html>\r\n     <html lang=\"en\">\r\n     <head>\r\n         <meta charset=\"UTF-8\">\r\n         <title>Title</title>\r\n         <style>\r\n             /*类选择器样式:  .class的名称{}\r\n                 可以多个标签归类,是同一个class*/\r\n         .guodegang{\r\n             color: green;\r\n         }\r\n             .yuqian{\r\n                 color: red;\r\n             }\r\n         </style>\r\n     </head>\r\n     <body>\r\n     <h1 class=\"guodegang\">标题1</h1>\r\n     <h1 class=\"yuqian\">标题2</h1>\r\n     <h1>标题3</h1>\r\n     </body>\r\n     </html>\r\n     ```\r\n\r\n3. ID选择器\r\n\r\n   id选择器格式:----------#id名称{      }\r\n\r\n   ```html\r\n   <!DOCTYPE html>\r\n   <html lang=\"en\">\r\n   <head>\r\n       <meta charset=\"UTF-8\">\r\n       <title>Title</title>\r\n       <style>\r\n           /*id选择器格式:\r\n           #id名称{      }\r\n           不遵循就近原则;\r\n           id选择器>class选择器>标签选择器*/\r\n           #qinjiang{\r\n               color: aquamarine;\r\n           }\r\n           .style1{\r\n               color: blueviolet;\r\n           }\r\n           h1{\r\n               color: black;\r\n           }\r\n       </style>\r\n   </head>\r\n   <body>\r\n   <h1 id=\"qinjiang\">标题1</h1>\r\n   <h1 class=\"style1\">标题2</h1>\r\n   <h1 class=\"style1\">标题3</h1>\r\n   <h1 class=\"style1\">标题4</h1>\r\n   <h1>标题5</h1>\r\n   </body>\r\n   </html>\r\n   ```\r\n\r\n**不遵循就近原则;**\r\n==**id选择器>class选择器>标签选择器**==\r\n\r\n## 2.2 层次选择器\r\n\r\n1. 后代选择器\r\n\r\n   * 在某个元素后面的全部改变样式\r\n\r\n   * ```CSS\r\n     body p{\r\n         background: red;\r\n     }\r\n     ```\r\n\r\n2. 子类选择器\r\n\r\n   * 元素后面的子代改变样式---一代改变\r\n\r\n   * ```CSS\r\n     body>p{\r\n         background: yellow;\r\n     }\r\n     ```\r\n\r\n3. 相邻兄弟选择器\r\n\r\n   * 向下选择一个同辈改变样式\r\n\r\n   * ```CSS\r\n     .active + p{\r\n         background: blue;\r\n     }\r\n     ```\r\n\r\n4. 通用选择器\r\n\r\n   * 向下改变所有同辈样式\r\n\r\n   * ```CSS\r\n     .active~p{\r\n         background: green;\r\n     }\r\n     ```\r\n\r\n## 2.3 结构伪类选择器\r\n\r\n伪类:有条件\r\n\r\n样式:    class :条件\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <!--避免使用class；id选择器-->\r\n    <style>\r\n        /*ul的第一个元素*/\r\n        ul li:first-child {\r\n            background: red;\r\n        }\r\n        /*ul的最后一个元素*/\r\n        ul li:last-child{\r\n            background: yellow;\r\n        }\r\n        /*只选择p1:\r\n        第一步定位:p的父元素(p的第一个作用)\r\n        第二步定位父元素下的第一个元素(数字的作用)\r\n        第三步判断如果类型是p成立(p的第二个作用)\r\n        四步产生结果改变样式;*/\r\n        p:nth-child(1){\r\n            background: blue;\r\n        }\r\n        /*选中父元素\r\n        父元素下元素的第二个\r\n        父元素下的第二个元素类型如果是p\r\n        那么改变样式*/\r\n        p:nth-of-type(2){\r\n            background: green;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<!--<h1>h1</h1>-->\r\n<!--<p>p1</p>-->\r\n<p>p2   p:nth-child(1)</p>\r\n<p>p3   p:nth-of-type(2)</p>\r\n<ul>\r\n    <li>li1 ：ul li:first-child</li>\r\n    <li>li2</li>\r\n    <li>li3 ：ul li:last-child</li>\r\n</ul>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20200414174859084](image-20200414174859084.png)\r\n\r\n## ==2.4 属性选择器==\r\n\r\n> ```\r\n> 存在id属性的元素选中\r\n> 属性标签格式：a[]{};\r\n> 允许使用正则表达式：\r\n> =是绝对等于\r\n> *=是包含\r\n> ^=以。。。开头\r\n> $=以。。。结尾\r\n> ```\r\n\r\n# 3.美化页面元素\r\n\r\n## 3.1为什么要美化页面?\r\n\r\n1. 有效传递页面信息\r\n2. 美化网页,页面漂亮,才能吸引用户\r\n3. 图像页面主题\r\n4. 提高用户体验\r\n\r\n**span标签:重点要突出的字用span标签套起来;**\r\n\r\n## 3.2 字体样式\r\n\r\n```html\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <style>\r\n        #title1{\r\n            font-size: 50px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n欢迎学习<span id=\"title1\">Java</span>\r\n</body>\r\n</html>\r\n```\r\n\r\n```html\r\n    <style>\r\n     body{\r\n         font-family: \"Candara Light\", 楷体;\r\n     }\r\n        p{\r\n            font-size: 30px;\r\n        }\r\n        .p1{\r\n            font-family: 新宋体;\r\n        }\r\n    </style>\r\n```\r\n\r\n## 3.3 字体样式\r\n\r\n1. 颜色 color\r\n2. 对齐方式 text-align\r\n3. 首行缩进text-indent\r\n4. 行高 line-hight\r\n5. 装饰 text-decoration (下划线;中划线,上划线);none去除超链接下划线)\r\n6. 文本图片对齐:            img,span{vertical-align: middle;}\r\n\r\n```HTML\r\n<!--text-align:排版 集中;-->\r\n<!--text-indent:2em; 段首缩进-->\r\n<!--行高,与块高,一致可以垂直居中显示-->\r\n<!--水平对齐需要参照物 a,b -->\r\n<style>\r\n    h1{\r\n        color: #ffff34;\r\n        text-align: center;\r\n    }\r\n    .p1{\r\n        text-indent: 2em;\r\n    }\r\n    .p3{\r\n        background: blueviolet;\r\n        height: 100px;\r\n        line-height: 20px;\r\n    }\r\n    .l1{\r\n        text-decoration: underline;\r\n    }\r\n    .l2{\r\n        text-decoration: line-through;\r\n    }\r\n    .l3{\r\n        text-decoration:overline;\r\n    }\r\n    img,span{\r\n        vertical-align: middle;\r\n    }\r\n```\r\n\r\n**超链接样式**\r\n\r\n```css\r\na:link {color: #FF0000}     /* 未访问的链接 */\r\na:visited {color: #00FF00}  /* 已访问的链接 */\r\na:hover {color: #FF00FF}    /* 当有鼠标悬停在链接上 */\r\na:active {color: #0000FF}   /* 被选择的链接 */\r\ntext-shadow: deepskyblue 3px 5px 2px; /*阴影:颜色,水平偏移;垂直偏移,阴影大小*/\r\n```\r\n\r\n## 3.4  列表样式\r\n\r\n## 3.5  背景样式\r\n\r\n# 4.div盒子\r\n\r\n## 4.1什么是盒子?\r\n\r\n![image-20200415122508792](image-20200415122508792.png)\r\n\r\n\r\n\r\n\r\n\r\nmargin:外边距\r\n\r\npadding:内边距\r\n\r\nborder:边框\r\n\r\n## 4.2border:边框\r\n\r\n**body总有一个外边距不是零**\r\n\r\nbody{\r\n\r\n​	margin:0;\r\n\r\n​	padding:0;\r\n\r\n}//格式化\r\n\r\n**birder:粗细,样式,颜色**\r\n\r\n![image-20200415123658220](image-20200415123658220.png)\r\n\r\n## 4.3 内外边距\r\n\r\nmargin:0 0 0 0/上右下左\r\n\r\npadding:0 0 0 0/上右下左\r\n\r\n**外边距妙用:居中元素**\r\n\r\n## 4.4 圆角边框\r\n\r\nboder-radius:\r\n\r\n## 4.5 盒子阴影\r\n\r\nbox-shadow:10px 10px 10px yellow\r\n\r\n# 5.浮动\r\n\r\n## 5.1标准文档流\r\n\r\n## 5.2 display\r\n\r\n## 5.3 float\r\n\r\n## 5.4 父级边框塌陷问题\r\n\r\nclear:\r\n\r\n```html\r\nclear:right;右侧不允许浮动\r\nclaer:left 左侧不允许浮动\r\nclear:both 两侧不允许浮动\r\nclear:none;不允许浮动\r\n```\r\n\r\n解决方案:\r\n\r\n1. 增加父级元素高度\r\n\r\n2. 增加空div标签;清除浮动\r\n\r\n   ```html\r\n   clear\r\n   ```\r\n\r\n   \r\n\r\n3. overflow\r\n\r\n   ```html\r\n   在父级元素加 overflow:didden\r\n   ```\r\n\r\n4. 为父类添加一个伪类:after\r\n\r\n   ```html\r\n   #father:after{\r\n   	content:\'\';\r\n   	display:block\r\n   	clear:both\r\n   }\r\n   ```\r\n\r\n   \r\n\r\n#### 父元素边框塌陷问题小结\r\n\r\n1. 浮动元素后面加空div\r\n   简单,但是代码中尽量避免空div\r\n\r\n2. 设置父元素高度\r\n\r\n   简单,但是元素假设有了固定高度,就会被限制\r\n\r\n3. overflow\r\n   简单,但是下来在一些场景不美观;避免使用\r\n\r\n4. ==**给类添加以个伪类:after(推荐使用)**==\r\n   写法稍微复杂;但是没有副作用;\r\n\r\n## 5.5 对比display和float\r\n\r\n* display\r\n  方向不可控制\r\n* float\r\n  浮动起来,脱离表尊文档流.所以哟啊解决父级边框塌陷问题\r\n\r\n\r\n\r\n# 6.定位\r\n\r\n## 6.1 相对定位\r\n\r\n 相对定位:相对于自己原来的位置进行偏移;相对定位后仍然在标准文档流中.保留原来的位置\r\n\r\nposition: relative (相对定位)\r\n\r\n```html\r\ntop:-20px<!--减少与顶部的距离20px 效果:整体向上20px-->\r\nleft:20px<!--增加与左部的距离20px 效果:整体向右上20px-->\r\nbottom:-10px<!--减少与底部的距离10px 效果:整体向下20px-->\r\nright:10px<!--增加与右部的距离20px 效果:整体向左上20px-->\r\n```\r\n\r\n练习题:超链接宽高100px,粉色鼠标悬停蓝色;相对定位改变每一个div位置;\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <style>\r\n        /*超链接宽高100px,粉色鼠标悬停蓝色*/\r\n        a {\r\n            line-height: 100px;\r\n            text-align: center;\r\n            background: pink;\r\n            color: white;\r\n            display: block;\r\n            border: 0px solid black;\r\n            margin: 0;\r\n            padding: 0;\r\n            text-decoration-line: none;\r\n        }\r\n\r\n        a:hover {\r\n            background: dodgerblue;\r\n            color: white;\r\n            text-decoration-line: underline;\r\n        }\r\n\r\n        /*相对定位改变每一个div位置*/\r\n        div {\r\n            margin: 0;\r\n            padding: 0;\r\n            border: solid 0px black;\r\n\r\n        }\r\n\r\n        #father {\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            bottom: 0;\r\n            right: 0;\r\n            margin: auto;\r\n            height: 300px;\r\n            width: 300px;\r\n            padding: 10px;\r\n            border: red 1px solid;\r\n        }\r\n\r\n        #first {\r\n            height: 100px;\r\n            width: 100px;\r\n        }\r\n\r\n        #second {\r\n            height: 100px;\r\n            width: 100px;\r\n            position: relative;\r\n            right: -200px;\r\n            bottom: 100px;\r\n        }\r\n\r\n        #third {\r\n            height: 100px;\r\n            width: 100px;\r\n        }\r\n\r\n        #fourth {\r\n            height: 100px;\r\n            width: 100px;\r\n            position: relative;\r\n            left: 200px;\r\n            bottom: 100px;\r\n        }\r\n\r\n        #fifth {\r\n            height: 100px;\r\n            width: 100px;\r\n            position: relative;\r\n            left: 100px;\r\n            bottom: 300px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<div id=\"father\">\r\n    <div id=\"first\"><a href=\"http://baidu.com\" target=\"_blank\">链接1</a></div>\r\n    <div id=\"second\"><a href=\"http://bilibili.com\" target=\"_blank\">链接2</a></div>\r\n    <div id=\"third\"><a href=\"http://sogou.com\" target=\"_blank\">链接3</a></div>\r\n    <div id=\"fourth\"><a href=\"http://Google.com\" target=\"_blank\">链接4</a></div>\r\n    <div id=\"fifth\"><a href=\"https://translate.google.com/\" target=\"_blank\">链接5</a></div>\r\n\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 6.2 绝对定位\r\n\r\n绝对定位:\r\n\r\n1. 没有父级元素定位前提下:会相对于浏览器的边框位置进行偏移;\r\n2. 假设父级元素存在定位,默认通常会相对父级元素定偏移\r\n3. 只在父级元素内偏移\r\n\r\n**绝对定位:相对于父级或浏览器的位置惊醒偏移,偏移后不在标准文档流中;原来的位置不保留**\r\n\r\n## 6.3 固定定位\r\n\r\n```html\r\n<!--相对与页面不变的-->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <style>\r\n        body{\r\n            height: 1000px;\r\n        }\r\n        div:nth-of-type(1) {\r\n            width: 100px;\r\n            height: 100px;\r\n            background: red;\r\n            position: absolute;\r\n            right: 0;\r\n            bottom: 0;\r\n        }\r\n        div:nth-of-type(2){\r\n            width: 50px;\r\n            height: 50px;\r\n            background: green;\r\n            position: fixed;\r\n            right: 0;\r\n            bottom: 0;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<div>div1</div>\r\n<div>div2</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 6.4 z-index\r\n\r\n相当于PS图层概念\r\n\r\nCSS:\r\n\r\n```css\r\n#content{\r\n    padding: 0;\r\n    margin: 0;\r\n    width: 380px;\r\n    font-size: 12px;\r\n    overflow: hidden;\r\n    line-height: 25px;\r\n    border: 1px #000 solid;\r\n}\r\nul,li{\r\n    padding: 0;\r\n    margin: 0px;\r\n    list-style: none;\r\n}\r\n/*父级元素相对定位*/\r\n#content ul{\r\n    position: relative;\r\n}\r\n.tipText,.tipBg{\r\n    position: absolute;\r\n    width: 380px;\r\n    height: 25px;\r\n    top: 80px;\r\n\r\n}\r\n.tipText{\r\n    /*z-index: 10;*/\r\n    color: red;\r\n}\r\n.tipBg {\r\n    background: #000;\r\n    opacity: 0.5;<!-- 透明度设置 -->\r\n/*flter:Alpha(opacity = 50);  IE8以前用他替代opacity*/\r\n}\r\n```\r\n\r\nindex.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<link rel=\"stylesheet\" href=\"CSS/style.css\">\r\n<div id=\"content\">\r\n    <ul>\r\n        <li><img src=\"images/BaiDuLogo.png\" alt=\"\" alt></li>\r\n        <li class=\"tipText\">学习相声找郭德纲</li>\r\n        <li class=\"tipBg\"></li>\r\n        <li>时间:2099-01-01</li>\r\n        <li>地点:火星第一基地</li>\r\n    </ul>\r\n</div>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n# 7. 动画\r\n\r\n# 8.总结\r\n\r\n![image-20200415201741197](image-20200415201741197.png)', '2020-06-11 12:09:36', '什么是CSS', 'https://images.unsplash.com/photo-1588822145316-225034d86df7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '原创', b'1', b'1', b'1', 'CSS', '2020-06-11 12:09:36', 1, 64, 1, 0);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `blog_id` bigint(20) NULL DEFAULT NULL,
  `parent_comment_id` bigint(20) NULL DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (30, 'GodNight', '1927440193@qq.com', 'test', '/images/avatar.png', '2020-05-19 12:29:57', 62, -1, b'1');
INSERT INTO `t_comment` VALUES (31, 'GodNight', '1927440193@qq.com', 'test', '/images/avatar.png', '2020-05-19 12:30:05', 62, 30, b'1');
INSERT INTO `t_comment` VALUES (32, 'GodNight', '1927440193@qq.com', 'test', '/images/avatar.png', '2020-05-23 16:31:00', 63, -1, b'0');
INSERT INTO `t_comment` VALUES (33, 'GodNight', '1927440193@qq.com', 'test回复', '/images/avatar.png', '2020-05-23 16:31:18', 63, 32, b'0');
INSERT INTO `t_comment` VALUES (34, '小白', 'guan.long.feng@qq.com', '测试回复', '/images/avatar.png', '2020-05-23 08:39:35', 63, 32, b'0');
INSERT INTO `t_comment` VALUES (35, '小黑', '1927440193@qq.com', '评论测试', '/images/avatar.png', '2020-05-23 08:40:25', 63, -1, b'0');
INSERT INTO `t_comment` VALUES (36, 'GodNight', '1927440193@qq.com', '评论测试', '/images/avatar.png', '2020-05-23 08:40:39', 62, -1, b'0');
INSERT INTO `t_comment` VALUES (38, 'GodNight', '1927440193@qq.com', '评论', '/images/avatar.png', '2020-06-11 06:33:20', 73, -1, b'1');
INSERT INTO `t_comment` VALUES (39, '小白', '1927440193@qq.com', '回复', '/images/avatar.png', '2020-06-11 06:33:31', 73, 38, b'1');
INSERT INTO `t_comment` VALUES (40, '小黑', 'guan.long.feng@qq.com', '回复小白', '/images/avatar.png', '2020-06-11 06:34:06', 73, 39, b'1');

-- ----------------------------
-- Table structure for t_friend
-- ----------------------------
DROP TABLE IF EXISTS `t_friend`;
CREATE TABLE `t_friend`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `blogaddress` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blogname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `pictureaddress` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 59 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_friend
-- ----------------------------
INSERT INTO `t_friend` VALUES (58, 'http://www.zhuyiming.top/', '君の名は', '2020-05-19 12:31:45', 'https://images.unsplash.com/photo-1507608443039-bfde4fbcd142?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60');

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `parent_message_id` bigint(20) NULL DEFAULT NULL,
  `admin_message` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 107 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_message
-- ----------------------------
INSERT INTO `t_message` VALUES (1, 'GodNight', '1927440193@qq.com', '测试留言板', '/images/avatar.png', '2020-05-19 12:33:03', -1, b'1');
INSERT INTO `t_message` VALUES (101, 'GodNight', '1927440193@qq.com', '测试2', '/images/avatar.png', '2020-05-19 12:33:59', -1, b'1');
INSERT INTO `t_message` VALUES (102, 'GodNight', '1927440193@qq.com', '测试留言板', '/images/avatar.png', '2020-05-24 05:12:05', -1, b'1');
INSERT INTO `t_message` VALUES (103, '其他人', '1927440193@qq.com', '测试回复', '/images/avatar.png', '2020-05-24 05:12:13', 102, b'0');
INSERT INTO `t_message` VALUES (104, 'GodNight', '1927440193@qq.com', '20200610', '/images/avatar.png', '2020-06-10 06:51:29', 1, b'0');
INSERT INTO `t_message` VALUES (105, 'GodNight', '1927440193@qq.com', '留言', '/images/avatar.png', '2020-06-11 12:05:15', -1, b'0');
INSERT INTO `t_message` VALUES (106, 'GodNight', '1927440193@qq.com', '20200611', '/images/avatar.png', '2020-06-11 14:08:28', -1, b'0');

-- ----------------------------
-- Table structure for t_picture
-- ----------------------------
DROP TABLE IF EXISTS `t_picture`;
CREATE TABLE `t_picture`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `pictureaddress` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `picturedescription` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `picturename` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `picturetime` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_picture
-- ----------------------------
INSERT INTO `t_picture` VALUES (19, 'http://n.sinaimg.cn/sinacn20111/600/w1920h1080/20190331/0f41-huxwryw5226043.jpg', '测试使用', '风景01', '不详');
INSERT INTO `t_picture` VALUES (20, 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3462072388,1787902334&fm=26&gp=0.jpg', 'wlop鬼刀', 'wlop01', '2020-5  wlop壁纸');
INSERT INTO `t_picture` VALUES (21, 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1684280967,232880026&fm=26&gp=0.jpg', 'wlop鬼刀', 'wlop02', '2020-5  wlop壁纸');
INSERT INTO `t_picture` VALUES (22, 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2423510892,1438625309&fm=26&gp=0.jpg', 'wlop鬼刀', 'wlop03', '2020-5  wlop壁纸');
INSERT INTO `t_picture` VALUES (23, 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=860775400,1966721401&fm=26&gp=0.jpg', 'wlop鬼刀', 'wlop04', '2020-5  wlop');
INSERT INTO `t_picture` VALUES (24, 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2931635536,368099492&fm=26&gp=0.jpg', 'wlop鬼刀', 'wlop05', '2020-6  wlop壁纸');
INSERT INTO `t_picture` VALUES (25, 'https://images.unsplash.com/photo-1588615419957-bf66d53c6b49?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60', '一张图片', '风景02', '2020-6 风景');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 72 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (59, 'Java');
INSERT INTO `t_type` VALUES (60, 'JavaScript');
INSERT INTO `t_type` VALUES (61, 'Mybatis');
INSERT INTO `t_type` VALUES (62, 'MySQL');
INSERT INTO `t_type` VALUES (63, 'HTML');
INSERT INTO `t_type` VALUES (64, 'CSS');
INSERT INTO `t_type` VALUES (65, 'Spring');
INSERT INTO `t_type` VALUES (66, 'SpringMVC');
INSERT INTO `t_type` VALUES (67, 'SpringSecurity');
INSERT INTO `t_type` VALUES (68, 'SpringBoot');
INSERT INTO `t_type` VALUES (69, 'Maven1');
INSERT INTO `t_type` VALUES (70, 'Test分类');
INSERT INTO `t_type` VALUES (71, 'test');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int(11) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, '/images/avatar.png', '2020-04-01 12:23:53', '1927440193@qq.com', 'GodNight', 'e10adc3949ba59abbe56e057f20f883e', 1, '2020-04-01 12:24:37', 'admin');

SET FOREIGN_KEY_CHECKS = 1;
